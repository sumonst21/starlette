{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u2728 The little ASGI framework that shines. \u2728 Introduction Starlette is a lightweight ASGI framework/toolkit, which is ideal for building async web services in Python. It is production-ready, and gives you the following: A lightweight, low-complexity HTTP web framework. WebSocket support. In-process background tasks. Startup and shutdown events. Test client built on httpx . CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Few hard dependencies. Compatible with asyncio and trio backends. Great overall performance against independent benchmarks . Requirements Python 3.7+ (For Python 3.6 support, install version 0.19.1) Installation $ pip3 install starlette You'll also want to install an ASGI server, such as uvicorn , daphne , or hypercorn . $ pip3 install uvicorn Example example.py : from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) app = Starlette ( debug = True , routes = [ Route ( '/' , homepage ), ]) Then run the application... $ uvicorn example:app For a more complete example, see here . Dependencies Starlette only requires anyio , and the following dependencies are optional: httpx - Required if you want to use the TestClient . jinja2 - Required if you want to use Jinja2Templates . python-multipart - Required if you want to support form parsing, with request.form() . itsdangerous - Required for SessionMiddleware support. pyyaml - Required for SchemaGenerator support. You can install all of these with pip3 install starlette[full] . Framework or Toolkit Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently. from starlette.responses import PlainTextResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send ) Run the app application in example.py : $ uvicorn example:app INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) Run uvicorn with --reload to enable auto-reloading on code changes. Modularity The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications. The clean API separation also means it's easier to understand each component in isolation. Starlette is BSD licensed code. Designed & crafted with care. \u2014 \u2b50\ufe0f \u2014","title":"Introduction"},{"location":"#introduction","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building async web services in Python. It is production-ready, and gives you the following: A lightweight, low-complexity HTTP web framework. WebSocket support. In-process background tasks. Startup and shutdown events. Test client built on httpx . CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Few hard dependencies. Compatible with asyncio and trio backends. Great overall performance against independent benchmarks .","title":"Introduction"},{"location":"#requirements","text":"Python 3.7+ (For Python 3.6 support, install version 0.19.1)","title":"Requirements"},{"location":"#installation","text":"$ pip3 install starlette You'll also want to install an ASGI server, such as uvicorn , daphne , or hypercorn . $ pip3 install uvicorn","title":"Installation"},{"location":"#example","text":"example.py : from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) app = Starlette ( debug = True , routes = [ Route ( '/' , homepage ), ]) Then run the application... $ uvicorn example:app For a more complete example, see here .","title":"Example"},{"location":"#dependencies","text":"Starlette only requires anyio , and the following dependencies are optional: httpx - Required if you want to use the TestClient . jinja2 - Required if you want to use Jinja2Templates . python-multipart - Required if you want to support form parsing, with request.form() . itsdangerous - Required for SessionMiddleware support. pyyaml - Required for SchemaGenerator support. You can install all of these with pip3 install starlette[full] .","title":"Dependencies"},{"location":"#framework-or-toolkit","text":"Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently. from starlette.responses import PlainTextResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send ) Run the app application in example.py : $ uvicorn example:app INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) Run uvicorn with --reload to enable auto-reloading on code changes.","title":"Framework or Toolkit"},{"location":"#modularity","text":"The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications. The clean API separation also means it's easier to understand each component in isolation. Starlette is BSD licensed code. Designed & crafted with care. \u2014 \u2b50\ufe0f \u2014","title":"Modularity"},{"location":"applications/","text":"Starlette includes an application class Starlette that nicely ties together all of its other functionality. from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.routing import Route , Mount , WebSocketRoute from starlette.staticfiles import StaticFiles def homepage ( request ): return PlainTextResponse ( 'Hello, world!' ) def user_me ( request ): username = \"John Doe\" return PlainTextResponse ( 'Hello, %s !' % username ) def user ( request ): username = request . path_params [ 'username' ] return PlainTextResponse ( 'Hello, %s !' % username ) async def websocket_endpoint ( websocket ): await websocket . accept () await websocket . send_text ( 'Hello, websocket!' ) await websocket . close () def startup (): print ( 'Ready to go' ) routes = [ Route ( '/' , homepage ), Route ( '/user/me' , user_me ), Route ( '/user/ {username} ' , user ), WebSocketRoute ( '/ws' , websocket_endpoint ), Mount ( '/static' , StaticFiles ( directory = \"static\" )), ] app = Starlette ( debug = True , routes = routes , on_startup = [ startup ]) Instantiating the application class starlette.applications. Starlette ( debug=False , routes=None , middleware=None , exception_handlers=None , on_startup=None , on_shutdown=None , lifespan=None ) Creates an application instance. Parameters: debug - Boolean indicating if debug tracebacks should be returned on errors. routes - A list of routes to serve incoming HTTP and WebSocket requests. middleware - A list of middleware to run for every request. A starlette application will always automatically include two middleware classes. ServerErrorMiddleware is added as the very outermost middleware, to handle any uncaught errors occurring anywhere in the entire stack. ExceptionMiddleware is added as the very innermost middleware, to deal with handled exception cases occurring in the routing or endpoints. exception_handlers - A mapping of either integer status codes, or exception class types onto callables which handle the exceptions. Exception handler callables should be of the form handler(request, exc) -> response and may be be either standard functions, or async functions. on_startup - A list of callables to run on application startup. Startup handler callables do not take any arguments, and may be be either standard functions, or async functions. on_shutdown - A list of callables to run on application shutdown. Shutdown handler callables do not take any arguments, and may be be either standard functions, or async functions. Storing state on the app instance You can store arbitrary extra state on the application instance, using the generic app.state attribute. For example: app . state . ADMIN_EMAIL = 'admin@example.org' Accessing the app instance Where a request is available (i.e. endpoints and middleware), the app is available on request.app .","title":"Applications"},{"location":"applications/#instantiating-the-application","text":"class starlette.applications. Starlette ( debug=False , routes=None , middleware=None , exception_handlers=None , on_startup=None , on_shutdown=None , lifespan=None ) Creates an application instance. Parameters: debug - Boolean indicating if debug tracebacks should be returned on errors. routes - A list of routes to serve incoming HTTP and WebSocket requests. middleware - A list of middleware to run for every request. A starlette application will always automatically include two middleware classes. ServerErrorMiddleware is added as the very outermost middleware, to handle any uncaught errors occurring anywhere in the entire stack. ExceptionMiddleware is added as the very innermost middleware, to deal with handled exception cases occurring in the routing or endpoints. exception_handlers - A mapping of either integer status codes, or exception class types onto callables which handle the exceptions. Exception handler callables should be of the form handler(request, exc) -> response and may be be either standard functions, or async functions. on_startup - A list of callables to run on application startup. Startup handler callables do not take any arguments, and may be be either standard functions, or async functions. on_shutdown - A list of callables to run on application shutdown. Shutdown handler callables do not take any arguments, and may be be either standard functions, or async functions.","title":"Instantiating the application"},{"location":"applications/#storing-state-on-the-app-instance","text":"You can store arbitrary extra state on the application instance, using the generic app.state attribute. For example: app . state . ADMIN_EMAIL = 'admin@example.org'","title":"Storing state on the app instance"},{"location":"applications/#accessing-the-app-instance","text":"Where a request is available (i.e. endpoints and middleware), the app is available on request.app .","title":"Accessing the app instance"},{"location":"authentication/","text":"Starlette offers a simple but powerful interface for handling authentication and permissions. Once you've installed AuthenticationMiddleware with an appropriate authentication backend the request.user and request.auth interfaces will be available in your endpoints. from starlette.applications import Starlette from starlette.authentication import ( AuthCredentials , AuthenticationBackend , AuthenticationError , SimpleUser ) from starlette.middleware import Middleware from starlette.middleware.authentication import AuthenticationMiddleware from starlette.responses import PlainTextResponse from starlette.routing import Route import base64 import binascii class BasicAuthBackend ( AuthenticationBackend ): async def authenticate ( self , conn ): if \"Authorization\" not in conn . headers : return auth = conn . headers [ \"Authorization\" ] try : scheme , credentials = auth . split () if scheme . lower () != 'basic' : return decoded = base64 . b64decode ( credentials ) . decode ( \"ascii\" ) except ( ValueError , UnicodeDecodeError , binascii . Error ) as exc : raise AuthenticationError ( 'Invalid basic auth credentials' ) username , _ , password = decoded . partition ( \":\" ) # TODO: You'd want to verify the username and password here. return AuthCredentials ([ \"authenticated\" ]), SimpleUser ( username ) async def homepage ( request ): if request . user . is_authenticated : return PlainTextResponse ( 'Hello, ' + request . user . display_name ) return PlainTextResponse ( 'Hello, you' ) routes = [ Route ( \"/\" , endpoint = homepage ) ] middleware = [ Middleware ( AuthenticationMiddleware , backend = BasicAuthBackend ()) ] app = Starlette ( routes = routes , middleware = middleware ) Users Once AuthenticationMiddleware is installed the request.user interface will be available to endpoints or other middleware. This interface should subclass BaseUser , which provides two properties, as well as whatever other information your user model includes. .is_authenticated .display_name Starlette provides two built-in user implementations: UnauthenticatedUser() , and SimpleUser(username) . AuthCredentials It is important that authentication credentials are treated as separate concept from users. An authentication scheme should be able to restrict or grant particular privileges independently of the user identity. The AuthCredentials class provides the basic interface that request.auth exposes: .scopes Permissions Permissions are implemented as an endpoint decorator, that enforces that the incoming request includes the required authentication scopes. from starlette.authentication import requires @requires ( 'authenticated' ) async def dashboard ( request ): ... You can include either one or multiple required scopes: from starlette.authentication import requires @requires ([ 'authenticated' , 'admin' ]) async def dashboard ( request ): ... By default 403 responses will be returned when permissions are not granted. In some cases you might want to customize this, for example to hide information about the URL layout from unauthenticated users. from starlette.authentication import requires @requires ([ 'authenticated' , 'admin' ], status_code = 404 ) async def dashboard ( request ): ... Note The status_code parameter is not supported with WebSockets. The 403 (Forbidden) status code will always be used for those. Alternatively you might want to redirect unauthenticated users to a different page. from starlette.authentication import requires async def homepage ( request ): ... @requires ( 'authenticated' , redirect = 'homepage' ) async def dashboard ( request ): ... When redirecting users, the page you redirect them to will include URL they originally requested at the next query param: from starlette.authentication import requires from starlette.responses import RedirectResponse @requires ( 'authenticated' , redirect = 'login' ) async def admin ( request ): ... async def login ( request ): if request . method == \"POST\" : # Now that the user is authenticated, # we can send them to their original request destination if request . user . is_authenticated : next_url = request . query_params . get ( \"next\" ) if next_url : return RedirectResponse ( next_url ) return RedirectResponse ( \"/\" ) For class-based endpoints, you should wrap the decorator around a method on the class. from starlette.authentication import requires from starlette.endpoints import HTTPEndpoint class Dashboard ( HTTPEndpoint ): @requires ( \"authenticated\" ) async def get ( self , request ): ... Custom authentication error responses You can customise the error response sent when a AuthenticationError is raised by an auth backend: from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.authentication import AuthenticationMiddleware from starlette.requests import Request from starlette.responses import JSONResponse def on_auth_error ( request : Request , exc : Exception ): return JSONResponse ({ \"error\" : str ( exc )}, status_code = 401 ) app = Starlette ( middleware = [ Middleware ( AuthenticationMiddleware , backend = BasicAuthBackend (), on_error = on_auth_error ), ], )","title":"Authentication"},{"location":"authentication/#users","text":"Once AuthenticationMiddleware is installed the request.user interface will be available to endpoints or other middleware. This interface should subclass BaseUser , which provides two properties, as well as whatever other information your user model includes. .is_authenticated .display_name Starlette provides two built-in user implementations: UnauthenticatedUser() , and SimpleUser(username) .","title":"Users"},{"location":"authentication/#authcredentials","text":"It is important that authentication credentials are treated as separate concept from users. An authentication scheme should be able to restrict or grant particular privileges independently of the user identity. The AuthCredentials class provides the basic interface that request.auth exposes: .scopes","title":"AuthCredentials"},{"location":"authentication/#permissions","text":"Permissions are implemented as an endpoint decorator, that enforces that the incoming request includes the required authentication scopes. from starlette.authentication import requires @requires ( 'authenticated' ) async def dashboard ( request ): ... You can include either one or multiple required scopes: from starlette.authentication import requires @requires ([ 'authenticated' , 'admin' ]) async def dashboard ( request ): ... By default 403 responses will be returned when permissions are not granted. In some cases you might want to customize this, for example to hide information about the URL layout from unauthenticated users. from starlette.authentication import requires @requires ([ 'authenticated' , 'admin' ], status_code = 404 ) async def dashboard ( request ): ... Note The status_code parameter is not supported with WebSockets. The 403 (Forbidden) status code will always be used for those. Alternatively you might want to redirect unauthenticated users to a different page. from starlette.authentication import requires async def homepage ( request ): ... @requires ( 'authenticated' , redirect = 'homepage' ) async def dashboard ( request ): ... When redirecting users, the page you redirect them to will include URL they originally requested at the next query param: from starlette.authentication import requires from starlette.responses import RedirectResponse @requires ( 'authenticated' , redirect = 'login' ) async def admin ( request ): ... async def login ( request ): if request . method == \"POST\" : # Now that the user is authenticated, # we can send them to their original request destination if request . user . is_authenticated : next_url = request . query_params . get ( \"next\" ) if next_url : return RedirectResponse ( next_url ) return RedirectResponse ( \"/\" ) For class-based endpoints, you should wrap the decorator around a method on the class. from starlette.authentication import requires from starlette.endpoints import HTTPEndpoint class Dashboard ( HTTPEndpoint ): @requires ( \"authenticated\" ) async def get ( self , request ): ...","title":"Permissions"},{"location":"authentication/#custom-authentication-error-responses","text":"You can customise the error response sent when a AuthenticationError is raised by an auth backend: from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.authentication import AuthenticationMiddleware from starlette.requests import Request from starlette.responses import JSONResponse def on_auth_error ( request : Request , exc : Exception ): return JSONResponse ({ \"error\" : str ( exc )}, status_code = 401 ) app = Starlette ( middleware = [ Middleware ( AuthenticationMiddleware , backend = BasicAuthBackend (), on_error = on_auth_error ), ], )","title":"Custom authentication error responses"},{"location":"background/","text":"Starlette includes a BackgroundTask class for in-process background tasks. A background task should be attached to a response, and will run only once the response has been sent. Background Task Used to add a single background task to a response. Signature: BackgroundTask(func, *args, **kwargs) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from starlette.background import BackgroundTask ... async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] task = BackgroundTask ( send_welcome_email , to_address = email ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = task ) async def send_welcome_email ( to_address ): ... routes = [ ... Route ( '/user/signup' , endpoint = signup , methods = [ 'POST' ]) ] app = Starlette ( routes = routes ) BackgroundTasks Used to add multiple background tasks to a response. Signature: BackgroundTasks(tasks=[]) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTasks async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] tasks = BackgroundTasks () tasks . add_task ( send_welcome_email , to_address = email ) tasks . add_task ( send_admin_notification , username = username ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = tasks ) async def send_welcome_email ( to_address ): ... async def send_admin_notification ( username ): ... routes = [ Route ( '/user/signup' , endpoint = signup , methods = [ 'POST' ]) ] app = Starlette ( routes = routes ) Important The tasks are executed in order. In case one of the tasks raises an exception, the following tasks will not get the opportunity to be executed.","title":"Background Tasks"},{"location":"background/#background-task","text":"Used to add a single background task to a response. Signature: BackgroundTask(func, *args, **kwargs) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from starlette.background import BackgroundTask ... async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] task = BackgroundTask ( send_welcome_email , to_address = email ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = task ) async def send_welcome_email ( to_address ): ... routes = [ ... Route ( '/user/signup' , endpoint = signup , methods = [ 'POST' ]) ] app = Starlette ( routes = routes )","title":"Background Task"},{"location":"background/#backgroundtasks","text":"Used to add multiple background tasks to a response. Signature: BackgroundTasks(tasks=[]) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTasks async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] tasks = BackgroundTasks () tasks . add_task ( send_welcome_email , to_address = email ) tasks . add_task ( send_admin_notification , username = username ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = tasks ) async def send_welcome_email ( to_address ): ... async def send_admin_notification ( username ): ... routes = [ Route ( '/user/signup' , endpoint = signup , methods = [ 'POST' ]) ] app = Starlette ( routes = routes ) Important The tasks are executed in order. In case one of the tasks raises an exception, the following tasks will not get the opportunity to be executed.","title":"BackgroundTasks"},{"location":"config/","text":"Starlette encourages a strict separation of configuration from code, following the twelve-factor pattern . Configuration should be stored in environment variables, or in a \".env\" file that is not committed to source control. app.py : import databases from starlette.applications import Starlette from starlette.config import Config from starlette.datastructures import CommaSeparatedStrings , Secret # Config will be read from environment variables and/or \".env\" files. config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = databases . DatabaseURL ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) ALLOWED_HOSTS = config ( 'ALLOWED_HOSTS' , cast = CommaSeparatedStrings ) app = Starlette ( debug = DEBUG ) ... .env : # Don't commit this to source control. # Eg. Include \".env\" in your `.gitignore` file. DEBUG = True DATABASE_URL = postgresql://localhost/myproject SECRET_KEY = 43n080musdfjt54t-09sdgr ALLOWED_HOSTS = 127 .0.0.1, localhost Configuration precedence The order in which configuration values are read is: From an environment variable. From the \".env\" file. The default value given in config . If none of those match, then config(...) will raise an error. Secrets For sensitive keys, the Secret class is useful, since it helps minimize occasions where the value it holds could leak out into tracebacks or other code introspection. To get the value of a Secret instance, you must explicitly cast it to a string. You should only do this at the point at which the value is used. >>> from myproject import settings >>> settings . SECRET_KEY Secret ( '**********' ) >>> str ( settings . SECRET_KEY ) '98n349$%8b8-7yjn0n8y93T$23r' Similarly, the URL class will hide any password component in their representations. >>> from myproject import settings >>> settings . DATABASE_URL DatabaseURL ( 'postgresql://admin:**********@192.168.0.8/my-application' ) >>> str ( settings . DATABASE_URL ) 'postgresql://admin:Fkjh348htGee4t3@192.168.0.8/my-application' CommaSeparatedStrings For holding multiple inside a single config key, the CommaSeparatedStrings type is useful. >>> from myproject import settings >>> print ( settings . ALLOWED_HOSTS ) CommaSeparatedStrings ([ '127.0.0.1' , 'localhost' ]) >>> print ( list ( settings . ALLOWED_HOSTS )) [ '127.0.0.1' , 'localhost' ] >>> print ( len ( settings . ALLOWED_HOSTS )) 2 >>> print ( settings . ALLOWED_HOSTS [ 0 ]) '127.0.0.1' Reading or modifying the environment In some cases you might want to read or modify the environment variables programmatically. This is particularly useful in testing, where you may want to override particular keys in the environment. Rather than reading or writing from os.environ , you should use Starlette's environ instance. This instance is a mapping onto the standard os.environ that additionally protects you by raising an error if any environment variable is set after the point that it has already been read by the configuration. If you're using pytest , then you can setup any initial environment in tests/conftest.py . tests/conftest.py : from starlette.config import environ environ [ 'TESTING' ] = 'TRUE' A full example Structuring large applications can be complex. You need proper separation of configuration and code, database isolation during tests, separate test and production databases, etc... Here we'll take a look at a complete example, that demonstrates how we can start to structure an application. First, let's keep our settings, our database table definitions, and our application logic separated: myproject/settings.py : import databases from starlette.config import Config from starlette.datastructures import Secret config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) TESTING = config ( 'TESTING' , cast = bool , default = False ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) DATABASE_URL = config ( 'DATABASE_URL' , cast = databases . DatabaseURL ) if TESTING : DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) myproject/tables.py : import sqlalchemy # Database table definitions. metadata = sqlalchemy . MetaData () organisations = sqlalchemy . Table ( ... ) myproject/app.py from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.sessions import SessionMiddleware from starlette.routing import Route from myproject import settings async def homepage ( request ): ... routes = [ Route ( \"/\" , endpoint = homepage ) ] middleware = [ Middleware ( SessionMiddleware , secret_key = settings . SECRET_KEY , ) ] app = Starlette ( debug = settings . DEBUG , routes = routes , middleware = middleware ) Now let's deal with our test configuration. We'd like to create a new test database every time the test suite runs, and drop it once the tests complete. We'd also like to ensure tests/conftest.py : from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import create_database , database_exists , drop_database # This line would raise an error if we use it after 'settings' has been imported. environ [ 'TESTING' ] = 'TRUE' from myproject import settings from myproject.app import app from myproject.tables import metadata @pytest . fixture ( autouse = True , scope = \"session\" ) def setup_test_database (): \"\"\" Create a clean test database every time the tests are run. \"\"\" url = str ( settings . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest . fixture () def client (): \"\"\" Make a 'client' fixture available to test cases. \"\"\" # Our fixture is created within a context manager. This ensures that # application startup and shutdown run for every test case. with TestClient ( app ) as test_client : yield test_client","title":"Configuration"},{"location":"config/#configuration-precedence","text":"The order in which configuration values are read is: From an environment variable. From the \".env\" file. The default value given in config . If none of those match, then config(...) will raise an error.","title":"Configuration precedence"},{"location":"config/#secrets","text":"For sensitive keys, the Secret class is useful, since it helps minimize occasions where the value it holds could leak out into tracebacks or other code introspection. To get the value of a Secret instance, you must explicitly cast it to a string. You should only do this at the point at which the value is used. >>> from myproject import settings >>> settings . SECRET_KEY Secret ( '**********' ) >>> str ( settings . SECRET_KEY ) '98n349$%8b8-7yjn0n8y93T$23r' Similarly, the URL class will hide any password component in their representations. >>> from myproject import settings >>> settings . DATABASE_URL DatabaseURL ( 'postgresql://admin:**********@192.168.0.8/my-application' ) >>> str ( settings . DATABASE_URL ) 'postgresql://admin:Fkjh348htGee4t3@192.168.0.8/my-application'","title":"Secrets"},{"location":"config/#commaseparatedstrings","text":"For holding multiple inside a single config key, the CommaSeparatedStrings type is useful. >>> from myproject import settings >>> print ( settings . ALLOWED_HOSTS ) CommaSeparatedStrings ([ '127.0.0.1' , 'localhost' ]) >>> print ( list ( settings . ALLOWED_HOSTS )) [ '127.0.0.1' , 'localhost' ] >>> print ( len ( settings . ALLOWED_HOSTS )) 2 >>> print ( settings . ALLOWED_HOSTS [ 0 ]) '127.0.0.1'","title":"CommaSeparatedStrings"},{"location":"config/#reading-or-modifying-the-environment","text":"In some cases you might want to read or modify the environment variables programmatically. This is particularly useful in testing, where you may want to override particular keys in the environment. Rather than reading or writing from os.environ , you should use Starlette's environ instance. This instance is a mapping onto the standard os.environ that additionally protects you by raising an error if any environment variable is set after the point that it has already been read by the configuration. If you're using pytest , then you can setup any initial environment in tests/conftest.py . tests/conftest.py : from starlette.config import environ environ [ 'TESTING' ] = 'TRUE'","title":"Reading or modifying the environment"},{"location":"config/#a-full-example","text":"Structuring large applications can be complex. You need proper separation of configuration and code, database isolation during tests, separate test and production databases, etc... Here we'll take a look at a complete example, that demonstrates how we can start to structure an application. First, let's keep our settings, our database table definitions, and our application logic separated: myproject/settings.py : import databases from starlette.config import Config from starlette.datastructures import Secret config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) TESTING = config ( 'TESTING' , cast = bool , default = False ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) DATABASE_URL = config ( 'DATABASE_URL' , cast = databases . DatabaseURL ) if TESTING : DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) myproject/tables.py : import sqlalchemy # Database table definitions. metadata = sqlalchemy . MetaData () organisations = sqlalchemy . Table ( ... ) myproject/app.py from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.sessions import SessionMiddleware from starlette.routing import Route from myproject import settings async def homepage ( request ): ... routes = [ Route ( \"/\" , endpoint = homepage ) ] middleware = [ Middleware ( SessionMiddleware , secret_key = settings . SECRET_KEY , ) ] app = Starlette ( debug = settings . DEBUG , routes = routes , middleware = middleware ) Now let's deal with our test configuration. We'd like to create a new test database every time the test suite runs, and drop it once the tests complete. We'd also like to ensure tests/conftest.py : from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import create_database , database_exists , drop_database # This line would raise an error if we use it after 'settings' has been imported. environ [ 'TESTING' ] = 'TRUE' from myproject import settings from myproject.app import app from myproject.tables import metadata @pytest . fixture ( autouse = True , scope = \"session\" ) def setup_test_database (): \"\"\" Create a clean test database every time the tests are run. \"\"\" url = str ( settings . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest . fixture () def client (): \"\"\" Make a 'client' fixture available to test cases. \"\"\" # Our fixture is created within a context manager. This ensures that # application startup and shutdown run for every test case. with TestClient ( app ) as test_client : yield test_client","title":"A full example"},{"location":"contributing/","text":"Contributing Thank you for being interested in contributing to Starlette. There are many ways you can contribute to the project: Try Starlette and report bugs/issues you find Implement new features Review Pull Requests of others Write documentation Participate in discussions Reporting Bugs or Other Issues Found something that Starlette should support? Stumbled upon some unexpected behaviour? Contributions should generally start out with a discussion . Possible bugs may be raised as a \"Potential Issue\" discussion, feature requests may be raised as an \"Ideas\" discussion. We can then determine if the discussion needs to be escalated into an \"Issue\" or not, or if we'd consider a pull request. Try to be more descriptive as you can and in case of a bug report, provide as much information as possible like: OS platform Python version Installed dependencies and versions ( python -m pip freeze ) Code snippet Error traceback You should always try to reduce any examples to the simplest possible case that demonstrates the issue. Development To start developing Starlette, create a fork of the Starlette repository on GitHub. Then clone your fork with the following command replacing YOUR-USERNAME with your GitHub username: $ git clone https://github.com/YOUR-USERNAME/starlette You can now install the project and its dependencies using: $ cd starlette $ scripts/install Testing and Linting We use custom shell scripts to automate testing, linting, and documentation building workflow. To run the tests, use: $ scripts/test Any additional arguments will be passed to pytest . See the pytest documentation for more information. For example, to run a single test script: $ scripts/test tests/test_application.py To run the code auto-formatting: $ scripts/lint Lastly, to run code checks separately (they are also run as part of scripts/test ), run: $ scripts/check Documenting Documentation pages are located under the docs/ folder. To run the documentation site locally (useful for previewing changes), use: $ scripts/docs Resolving Build / CI Failures Once you've submitted your pull request, the test suite will automatically run, and the results will show up in GitHub. If the test suite fails, you'll want to click through to the \"Details\" link, and try to identify why the test suite failed. Here are some common ways the test suite can fail: Check Job Failed This job failing means there is either a code formatting issue or type-annotation issue. You can look at the job output to figure out why it's failed or within a shell run: $ scripts/check It may be worth it to run $ scripts/lint to attempt auto-formatting the code and if that job succeeds commit the changes. Docs Job Failed This job failing means the documentation failed to build. This can happen for a variety of reasons like invalid markdown or missing configuration within mkdocs.yml . Python 3.X Job Failed This job failing means the unit tests failed or not all code paths are covered by unit tests. If tests are failing you will see this message under the coverage report: === 1 failed, 435 passed, 1 skipped, 1 xfailed in 11.09s === If tests succeed but coverage doesn't reach our current threshold, you will see this message under the coverage report: FAIL Required test coverage of 100% not reached. Total coverage: 99.00% Releasing This section is targeted at Starlette maintainers. Before releasing a new version, create a pull request that includes: An update to the changelog : We follow the format from keepachangelog . Compare master with the tag of the latest release, and list all entries that are of interest to our users: Things that must go in the changelog: added, changed, deprecated or removed features, and bug fixes. Things that should not go in the changelog: changes to documentation, tests or tooling. Try sorting entries in descending order of impact / importance. Keep it concise and to-the-point. \ud83c\udfaf A version bump : see __version__.py . For an example, see #1600 . Once the release PR is merged, create a new release including: Tag version like 0.13.3 . Release title Version 0.13.3 Description copied from the changelog. Once created this release will be automatically uploaded to PyPI. If something goes wrong with the PyPI job the release can be published using the scripts/publish script.","title":"Contributing"},{"location":"contributing/#contributing","text":"Thank you for being interested in contributing to Starlette. There are many ways you can contribute to the project: Try Starlette and report bugs/issues you find Implement new features Review Pull Requests of others Write documentation Participate in discussions","title":"Contributing"},{"location":"contributing/#reporting-bugs-or-other-issues","text":"Found something that Starlette should support? Stumbled upon some unexpected behaviour? Contributions should generally start out with a discussion . Possible bugs may be raised as a \"Potential Issue\" discussion, feature requests may be raised as an \"Ideas\" discussion. We can then determine if the discussion needs to be escalated into an \"Issue\" or not, or if we'd consider a pull request. Try to be more descriptive as you can and in case of a bug report, provide as much information as possible like: OS platform Python version Installed dependencies and versions ( python -m pip freeze ) Code snippet Error traceback You should always try to reduce any examples to the simplest possible case that demonstrates the issue.","title":"Reporting Bugs or Other Issues"},{"location":"contributing/#development","text":"To start developing Starlette, create a fork of the Starlette repository on GitHub. Then clone your fork with the following command replacing YOUR-USERNAME with your GitHub username: $ git clone https://github.com/YOUR-USERNAME/starlette You can now install the project and its dependencies using: $ cd starlette $ scripts/install","title":"Development"},{"location":"contributing/#testing-and-linting","text":"We use custom shell scripts to automate testing, linting, and documentation building workflow. To run the tests, use: $ scripts/test Any additional arguments will be passed to pytest . See the pytest documentation for more information. For example, to run a single test script: $ scripts/test tests/test_application.py To run the code auto-formatting: $ scripts/lint Lastly, to run code checks separately (they are also run as part of scripts/test ), run: $ scripts/check","title":"Testing and Linting"},{"location":"contributing/#documenting","text":"Documentation pages are located under the docs/ folder. To run the documentation site locally (useful for previewing changes), use: $ scripts/docs","title":"Documenting"},{"location":"contributing/#resolving-build-ci-failures","text":"Once you've submitted your pull request, the test suite will automatically run, and the results will show up in GitHub. If the test suite fails, you'll want to click through to the \"Details\" link, and try to identify why the test suite failed. Here are some common ways the test suite can fail:","title":"Resolving Build / CI Failures"},{"location":"contributing/#check-job-failed","text":"This job failing means there is either a code formatting issue or type-annotation issue. You can look at the job output to figure out why it's failed or within a shell run: $ scripts/check It may be worth it to run $ scripts/lint to attempt auto-formatting the code and if that job succeeds commit the changes.","title":"Check Job Failed"},{"location":"contributing/#docs-job-failed","text":"This job failing means the documentation failed to build. This can happen for a variety of reasons like invalid markdown or missing configuration within mkdocs.yml .","title":"Docs Job Failed"},{"location":"contributing/#python-3x-job-failed","text":"This job failing means the unit tests failed or not all code paths are covered by unit tests. If tests are failing you will see this message under the coverage report: === 1 failed, 435 passed, 1 skipped, 1 xfailed in 11.09s === If tests succeed but coverage doesn't reach our current threshold, you will see this message under the coverage report: FAIL Required test coverage of 100% not reached. Total coverage: 99.00%","title":"Python 3.X Job Failed"},{"location":"contributing/#releasing","text":"This section is targeted at Starlette maintainers. Before releasing a new version, create a pull request that includes: An update to the changelog : We follow the format from keepachangelog . Compare master with the tag of the latest release, and list all entries that are of interest to our users: Things that must go in the changelog: added, changed, deprecated or removed features, and bug fixes. Things that should not go in the changelog: changes to documentation, tests or tooling. Try sorting entries in descending order of impact / importance. Keep it concise and to-the-point. \ud83c\udfaf A version bump : see __version__.py . For an example, see #1600 . Once the release PR is merged, create a new release including: Tag version like 0.13.3 . Release title Version 0.13.3 Description copied from the changelog. Once created this release will be automatically uploaded to PyPI. If something goes wrong with the PyPI job the release can be published using the scripts/publish script.","title":"Releasing"},{"location":"database/","text":"Starlette is not strictly tied to any particular database implementation. You can use it with an asynchronous ORM, such as GINO , or use regular non-async endpoints, and integrate with SQLAlchemy . In this documentation we'll demonstrate how to integrate against the databases package , which provides SQLAlchemy core support against a range of different database drivers. Here's a complete example, that includes table definitions, configuring a database.Database instance, and a couple of endpoints that interact with the database. .env DATABASE_URL = sqlite:///test.db app.py import databases import sqlalchemy from starlette.applications import Starlette from starlette.config import Config from starlette.responses import JSONResponse from starlette.routing import Route # Configuration from environment variables or '.env' file. config = Config ( '.env' ) DATABASE_URL = config ( 'DATABASE_URL' ) # Database table definitions. metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) database = databases . Database ( DATABASE_URL ) # Main application code. async def list_notes ( request ): query = notes . select () results = await database . fetch_all ( query ) content = [ { \"text\" : result [ \"text\" ], \"completed\" : result [ \"completed\" ] } for result in results ] return JSONResponse ( content ) async def add_note ( request ): data = await request . json () query = notes . insert () . values ( text = data [ \"text\" ], completed = data [ \"completed\" ] ) await database . execute ( query ) return JSONResponse ({ \"text\" : data [ \"text\" ], \"completed\" : data [ \"completed\" ] }) routes = [ Route ( \"/notes\" , endpoint = list_notes , methods = [ \"GET\" ]), Route ( \"/notes\" , endpoint = add_note , methods = [ \"POST\" ]), ] app = Starlette ( routes = routes , on_startup = [ database . connect ], on_shutdown = [ database . disconnect ] ) Finally, you will need to create the database tables. It is recommended to use Alembic, which we briefly go over in Migrations Queries Queries may be made with as SQLAlchemy Core queries . The following methods are supported: rows = await database.fetch_all(query) row = await database.fetch_one(query) async for row in database.iterate(query) await database.execute(query) await database.execute_many(query) Transactions Database transactions are available either as a decorator, as a context manager, or as a low-level API. Using a decorator on an endpoint: @database . transaction () async def populate_note ( request ): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await database . execute ( query ) raise RuntimeError () Using a context manager: async def populate_note ( request ): async with database . transaction (): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () Using the low-level API: async def populate_note ( request ): transaction = await database . transaction () try : # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await database . execute ( query ) raise RuntimeError () except : await transaction . rollback () raise else : await transaction . commit () Test isolation There are a few things that we want to ensure when running tests against a service that uses a database. Our requirements should be: Use a separate database for testing. Create a new test database every time we run the tests. Ensure that the database state is isolated between each test case. Here's how we need to structure our application and tests in order to meet those requirements: from starlette.applications import Starlette from starlette.config import Config import databases config = Config ( \".env\" ) TESTING = config ( 'TESTING' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = databases . DatabaseURL ) TEST_DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) # Use 'force_rollback' during testing, to ensure we do not persist database changes # between each test case. if TESTING : database = databases . Database ( TEST_DATABASE_URL , force_rollback = True ) else : database = databases . Database ( DATABASE_URL ) We still need to set TESTING during a test run, and setup the test database. Assuming we're using py.test , here's how our conftest.py might look: import pytest from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database , drop_database # This sets `os.environ`, but provides some additional protection. # If we placed it below the application import, it would raise an error # informing us that 'TESTING' had already been read from the environment. environ [ 'TESTING' ] = 'True' import app @pytest . fixture ( scope = \"session\" , autouse = True ) def create_test_database (): \"\"\" Create a clean database on every test case. For safety, we should abort if a database already exists. We use the `sqlalchemy_utils` package here for a few helpers in consistently creating and dropping the database. \"\"\" url = str ( app . TEST_DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest . fixture () def client (): \"\"\" When using the 'client' fixture in test cases, we'll get full database rollbacks between test cases: def test_homepage(client): url = app.url_path_for('homepage') response = client.get(url) assert response.status_code == 200 \"\"\" with TestClient ( app ) as client : yield client Migrations You'll almost certainly need to be using database migrations in order to manage incremental changes to the database. For this we'd strongly recommend Alembic , which is written by the author of SQLAlchemy. $ pip install alembic $ alembic init migrations Now, you'll want to set things up so that Alembic references the configured DATABASE_URL, and uses your table metadata. In alembic.ini remove the following line: sqlalchemy.url = driver://user:pass@localhost/dbname In migrations/env.py , you need to set the 'sqlalchemy.url' configuration key, and the target_metadata variable. You'll want something like this: # The Alembic Config object. config = context . config # Configure Alembic to use our DATABASE_URL and our table definitions... import app config . set_main_option ( 'sqlalchemy.url' , str ( app . DATABASE_URL )) target_metadata = app . metadata ... Then, using our notes example above, create an initial revision: alembic revision -m \"Create notes table\" And populate the new file (within migrations/versions ) with the necessary directives: def upgrade (): op . create_table ( 'notes' , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) def downgrade (): op . drop_table ( 'notes' ) And run your first migration. Our notes app can now run! alembic upgrade head Running migrations during testing It is good practice to ensure that your test suite runs the database migrations every time it creates the test database. This will help catch any issues in your migration scripts, and will help ensure that the tests are running against a database that's in a consistent state with your live database. We can adjust the create_test_database fixture slightly: from alembic import command from alembic.config import Config import app ... @pytest . fixture ( scope = \"session\" , autouse = True ) def create_test_database (): url = str ( app . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. config = Config ( \"alembic.ini\" ) # Run the migrations. command . upgrade ( config , \"head\" ) yield # Run the tests. drop_database ( url ) # Drop the test database.","title":"Database"},{"location":"database/#queries","text":"Queries may be made with as SQLAlchemy Core queries . The following methods are supported: rows = await database.fetch_all(query) row = await database.fetch_one(query) async for row in database.iterate(query) await database.execute(query) await database.execute_many(query)","title":"Queries"},{"location":"database/#transactions","text":"Database transactions are available either as a decorator, as a context manager, or as a low-level API. Using a decorator on an endpoint: @database . transaction () async def populate_note ( request ): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await database . execute ( query ) raise RuntimeError () Using a context manager: async def populate_note ( request ): async with database . transaction (): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () Using the low-level API: async def populate_note ( request ): transaction = await database . transaction () try : # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await database . execute ( query ) raise RuntimeError () except : await transaction . rollback () raise else : await transaction . commit ()","title":"Transactions"},{"location":"database/#test-isolation","text":"There are a few things that we want to ensure when running tests against a service that uses a database. Our requirements should be: Use a separate database for testing. Create a new test database every time we run the tests. Ensure that the database state is isolated between each test case. Here's how we need to structure our application and tests in order to meet those requirements: from starlette.applications import Starlette from starlette.config import Config import databases config = Config ( \".env\" ) TESTING = config ( 'TESTING' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = databases . DatabaseURL ) TEST_DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) # Use 'force_rollback' during testing, to ensure we do not persist database changes # between each test case. if TESTING : database = databases . Database ( TEST_DATABASE_URL , force_rollback = True ) else : database = databases . Database ( DATABASE_URL ) We still need to set TESTING during a test run, and setup the test database. Assuming we're using py.test , here's how our conftest.py might look: import pytest from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database , drop_database # This sets `os.environ`, but provides some additional protection. # If we placed it below the application import, it would raise an error # informing us that 'TESTING' had already been read from the environment. environ [ 'TESTING' ] = 'True' import app @pytest . fixture ( scope = \"session\" , autouse = True ) def create_test_database (): \"\"\" Create a clean database on every test case. For safety, we should abort if a database already exists. We use the `sqlalchemy_utils` package here for a few helpers in consistently creating and dropping the database. \"\"\" url = str ( app . TEST_DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest . fixture () def client (): \"\"\" When using the 'client' fixture in test cases, we'll get full database rollbacks between test cases: def test_homepage(client): url = app.url_path_for('homepage') response = client.get(url) assert response.status_code == 200 \"\"\" with TestClient ( app ) as client : yield client","title":"Test isolation"},{"location":"database/#migrations","text":"You'll almost certainly need to be using database migrations in order to manage incremental changes to the database. For this we'd strongly recommend Alembic , which is written by the author of SQLAlchemy. $ pip install alembic $ alembic init migrations Now, you'll want to set things up so that Alembic references the configured DATABASE_URL, and uses your table metadata. In alembic.ini remove the following line: sqlalchemy.url = driver://user:pass@localhost/dbname In migrations/env.py , you need to set the 'sqlalchemy.url' configuration key, and the target_metadata variable. You'll want something like this: # The Alembic Config object. config = context . config # Configure Alembic to use our DATABASE_URL and our table definitions... import app config . set_main_option ( 'sqlalchemy.url' , str ( app . DATABASE_URL )) target_metadata = app . metadata ... Then, using our notes example above, create an initial revision: alembic revision -m \"Create notes table\" And populate the new file (within migrations/versions ) with the necessary directives: def upgrade (): op . create_table ( 'notes' , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) def downgrade (): op . drop_table ( 'notes' ) And run your first migration. Our notes app can now run! alembic upgrade head Running migrations during testing It is good practice to ensure that your test suite runs the database migrations every time it creates the test database. This will help catch any issues in your migration scripts, and will help ensure that the tests are running against a database that's in a consistent state with your live database. We can adjust the create_test_database fixture slightly: from alembic import command from alembic.config import Config import app ... @pytest . fixture ( scope = \"session\" , autouse = True ) def create_test_database (): url = str ( app . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. config = Config ( \"alembic.ini\" ) # Run the migrations. command . upgrade ( config , \"head\" ) yield # Run the tests. drop_database ( url ) # Drop the test database.","title":"Migrations"},{"location":"endpoints/","text":"Starlette includes the classes HTTPEndpoint and WebSocketEndpoint that provide a class-based view pattern for handling HTTP method dispatching and WebSocket sessions. HTTPEndpoint The HTTPEndpoint class can be used as an ASGI application: from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint class App ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to an HTTPEndpoint class. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint from starlette.routing import Route class Homepage ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) class User ( HTTPEndpoint ): async def get ( self , request ): username = request . path_params [ 'username' ] return PlainTextResponse ( f \"Hello, { username } \" ) routes = [ Route ( \"/\" , Homepage ), Route ( \"/ {username} \" , User ) ] app = Starlette ( routes = routes ) HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler. WebSocketEndpoint The WebSocketEndpoint class is an ASGI application that presents a wrapper around the functionality of a WebSocket instance. The ASGI connection scope is accessible on the endpoint instance via .scope and has an attribute encoding which may optionally be set, in order to validate the expected websocket data in the on_receive method. The encoding types are: 'json' 'bytes' 'text' There are three overridable methods for handling specific ASGI websocket message types: async def on_connect(websocket, **kwargs) async def on_receive(websocket, data) async def on_disconnect(websocket, close_code) from starlette.endpoints import WebSocketEndpoint class App ( WebSocketEndpoint ): encoding = 'bytes' async def on_connect ( self , websocket ): await websocket . accept () async def on_receive ( self , websocket , data ): await websocket . send_bytes ( b \"Message: \" + data ) async def on_disconnect ( self , websocket , close_code ): pass The WebSocketEndpoint can also be used with the Starlette application class: import uvicorn from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.responses import HTMLResponse from starlette.routing import Route , WebSocketRoute html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: { data } \" ) routes = [ Route ( \"/\" , Homepage ), WebSocketRoute ( \"/ws\" , Echo ) ] app = Starlette ( routes = routes )","title":"Endpoints"},{"location":"endpoints/#httpendpoint","text":"The HTTPEndpoint class can be used as an ASGI application: from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint class App ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to an HTTPEndpoint class. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint from starlette.routing import Route class Homepage ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) class User ( HTTPEndpoint ): async def get ( self , request ): username = request . path_params [ 'username' ] return PlainTextResponse ( f \"Hello, { username } \" ) routes = [ Route ( \"/\" , Homepage ), Route ( \"/ {username} \" , User ) ] app = Starlette ( routes = routes ) HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler.","title":"HTTPEndpoint"},{"location":"endpoints/#websocketendpoint","text":"The WebSocketEndpoint class is an ASGI application that presents a wrapper around the functionality of a WebSocket instance. The ASGI connection scope is accessible on the endpoint instance via .scope and has an attribute encoding which may optionally be set, in order to validate the expected websocket data in the on_receive method. The encoding types are: 'json' 'bytes' 'text' There are three overridable methods for handling specific ASGI websocket message types: async def on_connect(websocket, **kwargs) async def on_receive(websocket, data) async def on_disconnect(websocket, close_code) from starlette.endpoints import WebSocketEndpoint class App ( WebSocketEndpoint ): encoding = 'bytes' async def on_connect ( self , websocket ): await websocket . accept () async def on_receive ( self , websocket , data ): await websocket . send_bytes ( b \"Message: \" + data ) async def on_disconnect ( self , websocket , close_code ): pass The WebSocketEndpoint can also be used with the Starlette application class: import uvicorn from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.responses import HTMLResponse from starlette.routing import Route , WebSocketRoute html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: { data } \" ) routes = [ Route ( \"/\" , Homepage ), WebSocketRoute ( \"/ws\" , Echo ) ] app = Starlette ( routes = routes )","title":"WebSocketEndpoint"},{"location":"events/","text":"Starlette applications can register multiple event handlers for dealing with code that needs to run before the application starts up, or when the application is shutting down. Registering events These event handlers can either be async coroutines, or regular synchronous functions. The event handlers should be included on the application like so: from starlette.applications import Starlette async def some_startup_task (): pass async def some_shutdown_task (): pass routes = [ ... ] app = Starlette ( routes = routes , on_startup = [ some_startup_task ], on_shutdown = [ some_shutdown_task ] ) Starlette will not start serving any incoming requests until all of the registered startup handlers have completed. The shutdown handlers will run once all connections have been closed, and any in-process background tasks have completed. A single lifespan asynccontextmanager handler can be used instead of separate startup and shutdown handlers: import contextlib import anyio from starlette.applications import Starlette @contextlib . asynccontextmanager async def lifespan ( app ): async with some_async_resource (): yield routes = [ ... ] app = Starlette ( routes = routes , lifespan = lifespan ) Consider using anyio.create_task_group() for managing asynchronous tasks. Running event handlers in tests You might want to explicitly call into your event handlers in any test setup or test teardown code. Alternatively, you can use TestClient as a context manager, to ensure that startup and shutdown events are called. from example import app from starlette.testclient import TestClient def test_homepage (): with TestClient ( app ) as client : # Application 'on_startup' handlers are called on entering the block. response = client . get ( \"/\" ) assert response . status_code == 200 # Application 'on_shutdown' handlers are called on exiting the block.","title":"Events"},{"location":"events/#registering-events","text":"These event handlers can either be async coroutines, or regular synchronous functions. The event handlers should be included on the application like so: from starlette.applications import Starlette async def some_startup_task (): pass async def some_shutdown_task (): pass routes = [ ... ] app = Starlette ( routes = routes , on_startup = [ some_startup_task ], on_shutdown = [ some_shutdown_task ] ) Starlette will not start serving any incoming requests until all of the registered startup handlers have completed. The shutdown handlers will run once all connections have been closed, and any in-process background tasks have completed. A single lifespan asynccontextmanager handler can be used instead of separate startup and shutdown handlers: import contextlib import anyio from starlette.applications import Starlette @contextlib . asynccontextmanager async def lifespan ( app ): async with some_async_resource (): yield routes = [ ... ] app = Starlette ( routes = routes , lifespan = lifespan ) Consider using anyio.create_task_group() for managing asynchronous tasks.","title":"Registering events"},{"location":"events/#running-event-handlers-in-tests","text":"You might want to explicitly call into your event handlers in any test setup or test teardown code. Alternatively, you can use TestClient as a context manager, to ensure that startup and shutdown events are called. from example import app from starlette.testclient import TestClient def test_homepage (): with TestClient ( app ) as client : # Application 'on_startup' handlers are called on entering the block. response = client . get ( \"/\" ) assert response . status_code == 200 # Application 'on_shutdown' handlers are called on exiting the block.","title":"Running event handlers in tests"},{"location":"exceptions/","text":"Starlette allows you to install custom exception handlers to deal with how you return responses when errors or handled exceptions occur. from starlette.applications import Starlette from starlette.exceptions import HTTPException from starlette.requests import Request from starlette.responses import HTMLResponse HTML_404_PAGE = ... HTML_500_PAGE = ... async def not_found ( request : Request , exc : HTTPException ): return HTMLResponse ( content = HTML_404_PAGE , status_code = exc . status_code ) async def server_error ( request : Request , exc : HTTPException ): return HTMLResponse ( content = HTML_500_PAGE , status_code = exc . status_code ) exception_handlers = { 404 : not_found , 500 : server_error } app = Starlette ( routes = routes , exception_handlers = exception_handlers ) If debug is enabled and an error occurs, then instead of using the installed 500 handler, Starlette will respond with a traceback response. app = Starlette ( debug = True , routes = routes , exception_handlers = exception_handlers ) As well as registering handlers for specific status codes, you can also register handlers for classes of exceptions. In particular you might want to override how the built-in HTTPException class is handled. For example, to use JSON style responses: async def http_exception ( request : Request , exc : HTTPException ): return JSONResponse ({ \"detail\" : exc . detail }, status_code = exc . status_code ) exception_handlers = { HTTPException : http_exception } The HTTPException is also equipped with the headers argument. Which allows the propagation of the headers to the response class: async def http_exception ( request : Request , exc : HTTPException ): return JSONResponse ( { \"detail\" : exc . detail }, status_code = exc . status_code , headers = exc . headers ) You might also want to override how WebSocketException is handled: async def websocket_exception ( websocket : WebSocket , exc : WebSocketException ): await websocket . close ( code = 1008 ) exception_handlers = { WebSocketException : websocket_exception } Errors and handled exceptions It is important to differentiate between handled exceptions and errors. Handled exceptions do not represent error cases. They are coerced into appropriate HTTP responses, which are then sent through the standard middleware stack. By default the HTTPException class is used to manage any handled exceptions. Errors are any other exception that occurs within the application. These cases should bubble through the entire middleware stack as exceptions. Any error logging middleware should ensure that it re-raises the exception all the way up to the server. In practical terms, the error handled used is exception_handler[500] or exception_handler[Exception] . Both keys 500 and Exception can be used. See below: async def handle_error ( request : Request , exc : HTTPException ): # Perform some logic return JSONResponse ({ \"detail\" : exc . detail }, status_code = exc . status_code ) exception_handlers = { Exception : handle_error # or \"500: handle_error\" } It's important to notice that in case a BackgroundTask raises an exception, it will be handled by the handle_error function, but at that point, the response was already sent. In other words, the response created by handle_error will be discarded. In case the error happens before the response was sent, then it will use the response object - in the above example, the returned JSONResponse . In order to deal with this behaviour correctly, the middleware stack of a Starlette application is configured like this: ServerErrorMiddleware - Returns 500 responses when server errors occur. Installed middleware ExceptionMiddleware - Deals with handled exceptions, and returns responses. Router Endpoints HTTPException The HTTPException class provides a base class that you can use for any handled exceptions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None, headers=None) You should only raise HTTPException inside routing or endpoints. Middleware classes should instead just return appropriate responses directly. WebSocketException You can use the WebSocketException class to raise errors inside of WebSocket endpoints. WebSocketException(code=1008, reason=None) You can set any code valid as defined in the specification .","title":"Exceptions"},{"location":"exceptions/#errors-and-handled-exceptions","text":"It is important to differentiate between handled exceptions and errors. Handled exceptions do not represent error cases. They are coerced into appropriate HTTP responses, which are then sent through the standard middleware stack. By default the HTTPException class is used to manage any handled exceptions. Errors are any other exception that occurs within the application. These cases should bubble through the entire middleware stack as exceptions. Any error logging middleware should ensure that it re-raises the exception all the way up to the server. In practical terms, the error handled used is exception_handler[500] or exception_handler[Exception] . Both keys 500 and Exception can be used. See below: async def handle_error ( request : Request , exc : HTTPException ): # Perform some logic return JSONResponse ({ \"detail\" : exc . detail }, status_code = exc . status_code ) exception_handlers = { Exception : handle_error # or \"500: handle_error\" } It's important to notice that in case a BackgroundTask raises an exception, it will be handled by the handle_error function, but at that point, the response was already sent. In other words, the response created by handle_error will be discarded. In case the error happens before the response was sent, then it will use the response object - in the above example, the returned JSONResponse . In order to deal with this behaviour correctly, the middleware stack of a Starlette application is configured like this: ServerErrorMiddleware - Returns 500 responses when server errors occur. Installed middleware ExceptionMiddleware - Deals with handled exceptions, and returns responses. Router Endpoints","title":"Errors and handled exceptions"},{"location":"exceptions/#httpexception","text":"The HTTPException class provides a base class that you can use for any handled exceptions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None, headers=None) You should only raise HTTPException inside routing or endpoints. Middleware classes should instead just return appropriate responses directly.","title":"HTTPException"},{"location":"exceptions/#websocketexception","text":"You can use the WebSocketException class to raise errors inside of WebSocket endpoints. WebSocketException(code=1008, reason=None) You can set any code valid as defined in the specification .","title":"WebSocketException"},{"location":"graphql/","text":"GraphQL support in Starlette was deprecated in version 0.15.0, and removed in version 0.17.0. Although GraphQL support is no longer built in to Starlette, you can still use GraphQL with Starlette via 3rd party libraries. These libraries all have Starlette-specific guides to help you do just that: Ariadne starlette-graphene3 Strawberry tartiflette-asgi","title":"GraphQL"},{"location":"middleware/","text":"Starlette includes several middleware classes for adding behavior that is applied across your entire application. These are all implemented as standard ASGI middleware classes, and can be applied either to Starlette or to any other ASGI application. Using middleware The Starlette application class allows you to include the ASGI middleware in a way that ensures that it remains wrapped by the exception handler. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware from starlette.middleware.trustedhost import TrustedHostMiddleware routes = ... # Ensure that all requests include an 'example.com' or # '*.example.com' host header, and strictly enforce https-only access. middleware = [ Middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ], ), Middleware ( HTTPSRedirectMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) Every Starlette application automatically includes two pieces of middleware by default: ServerErrorMiddleware - Ensures that application exceptions may return a custom 500 page, or display an application traceback in DEBUG mode. This is always the outermost middleware layer. ExceptionMiddleware - Adds exception handlers, so that particular types of expected exception cases can be associated with handler functions. For example raising HTTPException(status_code=404) within an endpoint will end up rendering a custom 404 page. Middleware is evaluated from top-to-bottom, so the flow of execution in our example application would look like this: Middleware ServerErrorMiddleware TrustedHostMiddleware HTTPSRedirectMiddleware ExceptionMiddleware Routing Endpoint The following middleware implementations are available in the Starlette package: CORSMiddleware Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.cors import CORSMiddleware routes = ... middleware = [ Middleware ( CORSMiddleware , allow_origins = [ '*' ]) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: allow_origins - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False . expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [] . max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 600 . The middleware responds to two particular types of HTTP request... CORS preflight requests These are any OPTIONS request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes. Simple requests Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response. SessionMiddleware Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable. Access or modify the session data using the request.session dictionary interface. The following arguments are supported: secret_key - Should be a random string. session_cookie - Defaults to \"session\". max_age - Session expiry time in seconds. Defaults to 2 weeks. If set to None then the cookie will last as long as the browser session. same_site - SameSite flag prevents the browser from sending session cookie along with cross-site requests. Defaults to 'lax' . https_only - Indicate that Secure flag should be set (can be used with HTTPS only). Defaults to False . HTTPSRedirectMiddleware Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware routes = ... middleware = [ Middleware ( HTTPSRedirectMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) There are no configuration options for this middleware class. TrustedHostMiddleware Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.trustedhost import TrustedHostMiddleware routes = ... middleware = [ Middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent. GZipMiddleware Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.gzip import GZipMiddleware routes = ... middleware = [ Middleware ( GZipMiddleware , minimum_size = 1000 ) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 . The middleware won't GZip responses that already have a Content-Encoding set, to prevent them from being encoded twice. BaseHTTPMiddleware An abstract class that allows you to write ASGI middleware against a request/response interface. Usage To implement a middleware class using BaseHTTPMiddleware , you must override the async def dispatch(request, call_next) method. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.base import BaseHTTPMiddleware class CustomHeaderMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response routes = ... middleware = [ Middleware ( CustomHeaderMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) If you want to provide configuration options to the middleware class you should override the __init__ method, ensuring that the first argument is app , and any remaining arguments are optional keyword arguments. Make sure to set the app attribute on the instance if you do this. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app , header_value = 'Example' ): super () . __init__ ( app ) self . header_value = header_value async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = self . header_value return response middleware = [ Middleware ( CustomHeaderMiddleware , header_value = 'Customized' ) ] app = Starlette ( routes = routes , middleware = middleware ) Middleware classes should not modify their state outside of the __init__ method. Instead you should keep any state local to the dispatch method, or pass it around explicitly, rather than mutating the middleware instance. Limitations Currently, the BaseHTTPMiddleware has some known limitations: Using BaseHTTPMiddleware will prevent changes to contextlib.ContextVar s from propagating upwards. That is, if you set a value for a ContextVar in your endpoint and try to read it from a middleware you will find that the value is not the same value you set in your endpoint (see this test for an example of this behavior). To overcome these limitations, use pure ASGI middleware , as shown below. Pure ASGI Middleware The ASGI spec makes it possible to implement ASGI middleware using the ASGI interface directly, as a chain of ASGI applications that call into the next one. In fact, this is how middleware classes shipped with Starlette are implemented. This lower-level approach provides greater control over behavior and enhanced interoperability across frameworks and servers. It also overcomes the limitations of BaseHTTPMiddleware . Writing pure ASGI middleware The most common way to create an ASGI middleware is with a class. class ASGIMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): await self . app ( scope , receive , send ) The middleware above is the most basic ASGI middleware. It receives a parent ASGI application as an argument for its constructor, and implements an async __call__ method which calls into that parent application. Some implementations such as asgi-cors use an alternative style, using functions: import functools def asgi_middleware (): def asgi_decorator ( app ): @functools . wraps ( app ) async def wrapped_app ( scope , receive , send ): await app ( scope , receive , send ) return wrapped_app return asgi_decorator In any case, ASGI middleware must be callables that accept three arguments: scope , receive , and send . scope is a dict holding information about the connection, where scope[\"type\"] may be: \"http\" : for HTTP requests. \"websocket\" : for WebSocket connections. \"lifespan\" : for ASGI lifespan messages. receive and send can be used to exchange ASGI event messages with the ASGI server \u2014 more on this below. The type and contents of these messages depend on the scope type. Learn more in the ASGI specification . Using pure ASGI middleware Pure ASGI middleware can be used like any other middleware: from starlette.applications import Starlette from starlette.middleware import Middleware from .middleware import ASGIMiddleware routes = ... middleware = [ Middleware ( ASGIMiddleware ), ] app = Starlette ( ... , middleware = middleware ) See also Using middleware . Type annotations There are two ways of annotating a middleware: using Starlette itself or asgiref . Using Starlette: for most common use cases. from starlette.types import ASGIApp , Message , Scope , Receive , Send class ASGIMiddleware : def __init__ ( self , app : ASGIApp ) -> None : self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] != \"http\" : return await self . app ( scope , receive , send ) async def send_wrapper ( message : Message ) -> None : # ... Do something await send ( message ) await self . app ( scope , receive , send_wrapper ) Using asgiref : for more rigorous type hinting. from asgiref.typing import ASGI3Application , ASGIReceiveCallable , ASGISendCallable , Scope from asgiref.typing import ASGIReceiveEvent , ASGISendEvent class ASGIMiddleware : def __init__ ( self , app : ASGI3Application ) -> None : self . app = app async def __call__ ( self , scope : Scope , receive : ASGIReceiveCallable , send : ASGISendCallable ) -> None : if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return async def send_wrapper ( message : ASGISendEvent ) -> None : # ... Do something await send ( message ) return await self . app ( scope , receive , send_wrapper ) Common patterns Processing certain requests only ASGI middleware can apply specific behavior according to the contents of scope . For example, to only process HTTP requests, write this... class ASGIMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return ... # Do something here! await self . app ( scope , receive , send ) Likewise, WebSocket-only middleware would guard on scope[\"type\"] != \"websocket\" . The middleware may also act differently based on the request method, URL, headers, etc. Reusing Starlette components Starlette provides several data structures that accept the ASGI scope , receive and/or send arguments, allowing you to work at a higher level of abstraction. Such data structures include Request , Headers , QueryParams , URL , etc. For example, you can instantiate a Request to more easily inspect an HTTP request: from starlette.requests import Request class ASGIMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] == \"http\" : request = Request ( scope ) ... # Use `request.method`, `request.url`, `request.headers`, etc. await self . app ( scope , receive , send ) You can also reuse responses , which are ASGI applications as well. Sending eager responses Inspecting the connection scope allows you to conditionally call into a different ASGI app. One use case might be sending a response without calling into the app. As an example, this middleware uses a dictionary to perform permanent redirects based on the requested path. This could be used to implement ongoing support of legacy URLs in case you need to refactor route URL patterns. from starlette.datastructures import URL from starlette.responses import RedirectResponse class RedirectsMiddleware : def __init__ ( self , app , path_mapping : dict ): self . app = app self . path_mapping = path_mapping async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return url = URL ( scope = scope ) if url . path in self . path_mapping : url = url . replace ( path = self . path_mapping [ url . path ]) response = RedirectResponse ( url , status_code = 301 ) await response ( scope , receive , send ) return await self . app ( scope , receive , send ) Example usage would look like this: from starlette.applications import Starlette from starlette.middleware import Middleware routes = ... redirections = { \"/v1/resource/\" : \"/v2/resource/\" , # ... } middleware = [ Middleware ( RedirectsMiddleware , path_mapping = redirections ), ] app = Starlette ( routes = routes , middleware = middleware ) Inspecting or modifying the request Request information can be accessed or changed by manipulating the scope . For a full example of this pattern, see Uvicorn's ProxyHeadersMiddleware which inspects and tweaks the scope when serving behind a frontend proxy. Besides, wrapping the receive ASGI callable allows you to access or modify the HTTP request body by manipulating http.request ASGI event messages. As an example, this middleware computes and logs the size of the incoming request body... class LoggedRequestBodySizeMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return body_size = 0 async def receive_logging_request_body_size (): nonlocal body_size message = await receive () assert message [ \"type\" ] == \"http.request\" body_size += len ( message . get ( \"body\" , b \"\" )) if not message . get ( \"more_body\" , False ): print ( f \"Size of request body was: { body_size } bytes\" ) return message await self . app ( scope , receive_logging_request_body_size , send ) Likewise, WebSocket middleware may manipulate websocket.receive ASGI event messages to inspect or alter incoming WebSocket data. For an example that changes the HTTP request body, see msgpack-asgi . Inspecting or modifying the response Wrapping the send ASGI callable allows you to inspect or modify the HTTP response sent by the underlying application. To do so, react to http.response.start or http.response.body ASGI event messages. As an example, this middleware adds some fixed extra response headers: from starlette.datastructures import MutableHeaders class ExtraResponseHeadersMiddleware : def __init__ ( self , app , headers ): self . app = app self . headers = headers async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : return await self . app ( scope , receive , send ) async def send_with_extra_headers ( message ): if message [ \"type\" ] == \"http.response.start\" : headers = MutableHeaders ( scope = message ) for key , value in self . headers : headers . append ( key , value ) await send ( message ) await self . app ( scope , receive , send_with_extra_headers ) See also asgi-logger for an example that inspects the HTTP response and logs a configurable HTTP access log line. Likewise, WebSocket middleware may manipulate websocket.send ASGI event messages to inspect or alter outgoing WebSocket data. Note that if you change the response body, you will need to update the response Content-Length header to match the new response body length. See brotli-asgi for a complete example. Passing information to endpoints If you need to share information with the underlying app or endpoints, you may store it into the scope dictionary. Note that this is a convention -- for example, Starlette uses this to share routing information with endpoints -- but it is not part of the ASGI specification. If you do so, be sure to avoid conflicts by using keys that have low chances of being used by other middleware or applications. For example, when including the middleware below, endpoints would be able to access request.scope[\"asgi_transaction_id\"] . import uuid class TransactionIDMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): scope [ \"asgi_transaction_id\" ] = uuid . uuid4 () await self . app ( scope , receive , send ) Cleanup and error handling You can wrap the application in a try/except/finally block or a context manager to perform cleanup operations or do error handling. For example, the following middleware might collect metrics and process application exceptions... import time class MonitoringMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): start = time . time () try : await self . app ( scope , receive , send ) except Exception as exc : ... # Process the exception raise finally : end = time . time () elapsed = end - start ... # Submit `elapsed` as a metric to a monitoring backend See also timing-asgi for a full example of this pattern. Gotchas ASGI middleware should be stateless Because ASGI is designed to handle concurrent requests, any connection-specific state should be scoped to the __call__ implementation. Not doing so would typically lead to conflicting variable reads/writes across requests, and most likely bugs. As an example, this would conditionally replace the response body, if an X-Mock header is present in the response... \u2705 Do \u274c Don't from starlette.datastructures import Headers class MockResponseBodyMiddleware : def __init__ ( self , app , content ): self . app = app self . content = content async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return # A flag that we will turn `True` if the HTTP response # has the 'X-Mock' header. # \u2705: Scoped to this function. should_mock = False async def maybe_send_with_mock_content ( message ): nonlocal should_mock if message [ \"type\" ] == \"http.response.start\" : headers = Headers ( raw = message [ \"headers\" ]) should_mock = headers . get ( \"X-Mock\" ) == \"1\" await send ( message ) elif message [ \"type\" ] == \"http.response.body\" : if should_mock : message = { \"type\" : \"http.response.body\" , \"body\" : self . content } await send ( message ) await self . app ( scope , receive , maybe_send_with_mock_content ) from starlette.datastructures import Headers class MockResponseBodyMiddleware : def __init__ ( self , app , content ): self . app = app self . content = content # \u274c: This variable would be read and written across requests! self . should_mock = False async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return async def maybe_send_with_mock_content ( message ): if message [ \"type\" ] == \"http.response.start\" : headers = Headers ( raw = message [ \"headers\" ]) self . should_mock = headers . get ( \"X-Mock\" ) == \"1\" await send ( message ) elif message [ \"type\" ] == \"http.response.body\" : if self . should_mock : message = { \"type\" : \"http.response.body\" , \"body\" : self . content } await send ( message ) await self . app ( scope , receive , maybe_send_with_mock_content ) See also GZipMiddleware for a full example implementation that navigates this potential gotcha. Further reading This documentation should be enough to have a good basis on how to create an ASGI middleware. Nonetheless, there are great articles about the subject: Introduction to ASGI: Emergence of an Async Python Web Ecosystem How to write ASGI middleware Using middleware in other frameworks To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance: app = TrustedHostMiddleware ( app , allowed_hosts = [ 'example.com' ]) You can do this with a Starlette application instance too, but it is preferable to use the middleware=<List of Middleware instances> style, as it will: Ensure that everything remains wrapped in a single outermost ServerErrorMiddleware . Preserves the top-level app instance. Applying middleware to Mount s Middleware can also be added to Mount , which allows you to apply middleware to a single route, a group of routes or any mounted ASGI application: from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.gzip import GZipMiddleware from starlette.routing import Mount , Route routes = [ Mount ( \"/\" , routes = [ Route ( \"/example\" , endpoint =... , ) ], middleware = [ Middleware ( GZipMiddleware )] ) ] app = Starlette ( routes = routes ) Note that middleware used in this way is not wrapped in exception handling middleware like the middleware applied to the Starlette application is. This is often not a problem because it only applies to middleware that inspect or modify the Response , and even then you probably don't want to apply this logic to error responses. If you do want to apply the middleware logic to error responses only on some routes you have a couple of options: Add an ExceptionMiddleware onto the Mount Add a try/except block to your middleware and return an error response from there Split up marking and processing into two middlewares, one that gets put on Mount which marks the response as needing processing (for example by setting scope[\"log-response\"] = True ) and another applied to the Starlette application that does the heavy lifting. Third party middleware asgi-auth-github This middleware adds authentication to any ASGI application, requiring users to sign in using their GitHub account (via OAuth ). Access can be restricted to specific users or to members of specific GitHub organizations or teams. asgi-csrf Middleware for protecting against CSRF attacks. This middleware implements the Double Submit Cookie pattern, where a cookie is set, then it is compared to a csrftoken hidden form field or an x-csrftoken HTTP header. AuthlibMiddleware A drop-in replacement for Starlette session middleware, using authlib's jwt module. BugsnagMiddleware A middleware class for logging exceptions to Bugsnag . CSRFMiddleware Middleware for protecting against CSRF attacks. This middleware implements the Double Submit Cookie pattern, where a cookie is set, then it is compared to an x-csrftoken HTTP header. EarlyDataMiddleware Middleware and decorator for detecting and denying TLSv1.3 early data requests. PrometheusMiddleware A middleware class for capturing Prometheus metrics related to requests and responses, including in progress requests, timing... ProxyHeadersMiddleware Uvicorn includes a middleware class for determining the client IP address, when proxy servers are being used, based on the X-Forwarded-Proto and X-Forwarded-For headers. For more complex proxy configurations, you might want to adapt this middleware. RateLimitMiddleware A rate limit middleware. Regular expression matches url; flexible rules; highly customizable. Very easy to use. RequestIdMiddleware A middleware class for reading/generating request IDs and attaching them to application logs. RollbarMiddleware A middleware class for logging exceptions, errors, and log messages to Rollbar . SentryMiddleware A middleware class for logging exceptions to Sentry . StarletteOpentracing A middleware class that emits tracing info to OpenTracing.io compatible tracers and can be used to profile and monitor distributed applications. TimingMiddleware A middleware class to emit timing information (cpu and wall time) for each request which passes through it. Includes examples for how to emit these timings as statsd metrics. WSGIMiddleware A middleware class in charge of converting a WSGI application into an ASGI one.","title":"Middleware"},{"location":"middleware/#using-middleware","text":"The Starlette application class allows you to include the ASGI middleware in a way that ensures that it remains wrapped by the exception handler. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware from starlette.middleware.trustedhost import TrustedHostMiddleware routes = ... # Ensure that all requests include an 'example.com' or # '*.example.com' host header, and strictly enforce https-only access. middleware = [ Middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ], ), Middleware ( HTTPSRedirectMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) Every Starlette application automatically includes two pieces of middleware by default: ServerErrorMiddleware - Ensures that application exceptions may return a custom 500 page, or display an application traceback in DEBUG mode. This is always the outermost middleware layer. ExceptionMiddleware - Adds exception handlers, so that particular types of expected exception cases can be associated with handler functions. For example raising HTTPException(status_code=404) within an endpoint will end up rendering a custom 404 page. Middleware is evaluated from top-to-bottom, so the flow of execution in our example application would look like this: Middleware ServerErrorMiddleware TrustedHostMiddleware HTTPSRedirectMiddleware ExceptionMiddleware Routing Endpoint The following middleware implementations are available in the Starlette package:","title":"Using middleware"},{"location":"middleware/#corsmiddleware","text":"Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.cors import CORSMiddleware routes = ... middleware = [ Middleware ( CORSMiddleware , allow_origins = [ '*' ]) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: allow_origins - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False . expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [] . max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 600 . The middleware responds to two particular types of HTTP request...","title":"CORSMiddleware"},{"location":"middleware/#cors-preflight-requests","text":"These are any OPTIONS request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes.","title":"CORS preflight requests"},{"location":"middleware/#simple-requests","text":"Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.","title":"Simple requests"},{"location":"middleware/#sessionmiddleware","text":"Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable. Access or modify the session data using the request.session dictionary interface. The following arguments are supported: secret_key - Should be a random string. session_cookie - Defaults to \"session\". max_age - Session expiry time in seconds. Defaults to 2 weeks. If set to None then the cookie will last as long as the browser session. same_site - SameSite flag prevents the browser from sending session cookie along with cross-site requests. Defaults to 'lax' . https_only - Indicate that Secure flag should be set (can be used with HTTPS only). Defaults to False .","title":"SessionMiddleware"},{"location":"middleware/#httpsredirectmiddleware","text":"Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware routes = ... middleware = [ Middleware ( HTTPSRedirectMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) There are no configuration options for this middleware class.","title":"HTTPSRedirectMiddleware"},{"location":"middleware/#trustedhostmiddleware","text":"Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.trustedhost import TrustedHostMiddleware routes = ... middleware = [ Middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent.","title":"TrustedHostMiddleware"},{"location":"middleware/#gzipmiddleware","text":"Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.gzip import GZipMiddleware routes = ... middleware = [ Middleware ( GZipMiddleware , minimum_size = 1000 ) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 . The middleware won't GZip responses that already have a Content-Encoding set, to prevent them from being encoded twice.","title":"GZipMiddleware"},{"location":"middleware/#basehttpmiddleware","text":"An abstract class that allows you to write ASGI middleware against a request/response interface.","title":"BaseHTTPMiddleware"},{"location":"middleware/#usage","text":"To implement a middleware class using BaseHTTPMiddleware , you must override the async def dispatch(request, call_next) method. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.base import BaseHTTPMiddleware class CustomHeaderMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response routes = ... middleware = [ Middleware ( CustomHeaderMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) If you want to provide configuration options to the middleware class you should override the __init__ method, ensuring that the first argument is app , and any remaining arguments are optional keyword arguments. Make sure to set the app attribute on the instance if you do this. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app , header_value = 'Example' ): super () . __init__ ( app ) self . header_value = header_value async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = self . header_value return response middleware = [ Middleware ( CustomHeaderMiddleware , header_value = 'Customized' ) ] app = Starlette ( routes = routes , middleware = middleware ) Middleware classes should not modify their state outside of the __init__ method. Instead you should keep any state local to the dispatch method, or pass it around explicitly, rather than mutating the middleware instance.","title":"Usage"},{"location":"middleware/#limitations","text":"Currently, the BaseHTTPMiddleware has some known limitations: Using BaseHTTPMiddleware will prevent changes to contextlib.ContextVar s from propagating upwards. That is, if you set a value for a ContextVar in your endpoint and try to read it from a middleware you will find that the value is not the same value you set in your endpoint (see this test for an example of this behavior). To overcome these limitations, use pure ASGI middleware , as shown below.","title":"Limitations"},{"location":"middleware/#pure-asgi-middleware","text":"The ASGI spec makes it possible to implement ASGI middleware using the ASGI interface directly, as a chain of ASGI applications that call into the next one. In fact, this is how middleware classes shipped with Starlette are implemented. This lower-level approach provides greater control over behavior and enhanced interoperability across frameworks and servers. It also overcomes the limitations of BaseHTTPMiddleware .","title":"Pure ASGI Middleware"},{"location":"middleware/#writing-pure-asgi-middleware","text":"The most common way to create an ASGI middleware is with a class. class ASGIMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): await self . app ( scope , receive , send ) The middleware above is the most basic ASGI middleware. It receives a parent ASGI application as an argument for its constructor, and implements an async __call__ method which calls into that parent application. Some implementations such as asgi-cors use an alternative style, using functions: import functools def asgi_middleware (): def asgi_decorator ( app ): @functools . wraps ( app ) async def wrapped_app ( scope , receive , send ): await app ( scope , receive , send ) return wrapped_app return asgi_decorator In any case, ASGI middleware must be callables that accept three arguments: scope , receive , and send . scope is a dict holding information about the connection, where scope[\"type\"] may be: \"http\" : for HTTP requests. \"websocket\" : for WebSocket connections. \"lifespan\" : for ASGI lifespan messages. receive and send can be used to exchange ASGI event messages with the ASGI server \u2014 more on this below. The type and contents of these messages depend on the scope type. Learn more in the ASGI specification .","title":"Writing pure ASGI middleware"},{"location":"middleware/#using-pure-asgi-middleware","text":"Pure ASGI middleware can be used like any other middleware: from starlette.applications import Starlette from starlette.middleware import Middleware from .middleware import ASGIMiddleware routes = ... middleware = [ Middleware ( ASGIMiddleware ), ] app = Starlette ( ... , middleware = middleware ) See also Using middleware .","title":"Using pure ASGI middleware"},{"location":"middleware/#type-annotations","text":"There are two ways of annotating a middleware: using Starlette itself or asgiref . Using Starlette: for most common use cases. from starlette.types import ASGIApp , Message , Scope , Receive , Send class ASGIMiddleware : def __init__ ( self , app : ASGIApp ) -> None : self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] != \"http\" : return await self . app ( scope , receive , send ) async def send_wrapper ( message : Message ) -> None : # ... Do something await send ( message ) await self . app ( scope , receive , send_wrapper ) Using asgiref : for more rigorous type hinting. from asgiref.typing import ASGI3Application , ASGIReceiveCallable , ASGISendCallable , Scope from asgiref.typing import ASGIReceiveEvent , ASGISendEvent class ASGIMiddleware : def __init__ ( self , app : ASGI3Application ) -> None : self . app = app async def __call__ ( self , scope : Scope , receive : ASGIReceiveCallable , send : ASGISendCallable ) -> None : if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return async def send_wrapper ( message : ASGISendEvent ) -> None : # ... Do something await send ( message ) return await self . app ( scope , receive , send_wrapper )","title":"Type annotations"},{"location":"middleware/#common-patterns","text":"","title":"Common patterns"},{"location":"middleware/#processing-certain-requests-only","text":"ASGI middleware can apply specific behavior according to the contents of scope . For example, to only process HTTP requests, write this... class ASGIMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return ... # Do something here! await self . app ( scope , receive , send ) Likewise, WebSocket-only middleware would guard on scope[\"type\"] != \"websocket\" . The middleware may also act differently based on the request method, URL, headers, etc.","title":"Processing certain requests only"},{"location":"middleware/#reusing-starlette-components","text":"Starlette provides several data structures that accept the ASGI scope , receive and/or send arguments, allowing you to work at a higher level of abstraction. Such data structures include Request , Headers , QueryParams , URL , etc. For example, you can instantiate a Request to more easily inspect an HTTP request: from starlette.requests import Request class ASGIMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] == \"http\" : request = Request ( scope ) ... # Use `request.method`, `request.url`, `request.headers`, etc. await self . app ( scope , receive , send ) You can also reuse responses , which are ASGI applications as well.","title":"Reusing Starlette components"},{"location":"middleware/#sending-eager-responses","text":"Inspecting the connection scope allows you to conditionally call into a different ASGI app. One use case might be sending a response without calling into the app. As an example, this middleware uses a dictionary to perform permanent redirects based on the requested path. This could be used to implement ongoing support of legacy URLs in case you need to refactor route URL patterns. from starlette.datastructures import URL from starlette.responses import RedirectResponse class RedirectsMiddleware : def __init__ ( self , app , path_mapping : dict ): self . app = app self . path_mapping = path_mapping async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return url = URL ( scope = scope ) if url . path in self . path_mapping : url = url . replace ( path = self . path_mapping [ url . path ]) response = RedirectResponse ( url , status_code = 301 ) await response ( scope , receive , send ) return await self . app ( scope , receive , send ) Example usage would look like this: from starlette.applications import Starlette from starlette.middleware import Middleware routes = ... redirections = { \"/v1/resource/\" : \"/v2/resource/\" , # ... } middleware = [ Middleware ( RedirectsMiddleware , path_mapping = redirections ), ] app = Starlette ( routes = routes , middleware = middleware )","title":"Sending eager responses"},{"location":"middleware/#inspecting-or-modifying-the-request","text":"Request information can be accessed or changed by manipulating the scope . For a full example of this pattern, see Uvicorn's ProxyHeadersMiddleware which inspects and tweaks the scope when serving behind a frontend proxy. Besides, wrapping the receive ASGI callable allows you to access or modify the HTTP request body by manipulating http.request ASGI event messages. As an example, this middleware computes and logs the size of the incoming request body... class LoggedRequestBodySizeMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return body_size = 0 async def receive_logging_request_body_size (): nonlocal body_size message = await receive () assert message [ \"type\" ] == \"http.request\" body_size += len ( message . get ( \"body\" , b \"\" )) if not message . get ( \"more_body\" , False ): print ( f \"Size of request body was: { body_size } bytes\" ) return message await self . app ( scope , receive_logging_request_body_size , send ) Likewise, WebSocket middleware may manipulate websocket.receive ASGI event messages to inspect or alter incoming WebSocket data. For an example that changes the HTTP request body, see msgpack-asgi .","title":"Inspecting or modifying the request"},{"location":"middleware/#inspecting-or-modifying-the-response","text":"Wrapping the send ASGI callable allows you to inspect or modify the HTTP response sent by the underlying application. To do so, react to http.response.start or http.response.body ASGI event messages. As an example, this middleware adds some fixed extra response headers: from starlette.datastructures import MutableHeaders class ExtraResponseHeadersMiddleware : def __init__ ( self , app , headers ): self . app = app self . headers = headers async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : return await self . app ( scope , receive , send ) async def send_with_extra_headers ( message ): if message [ \"type\" ] == \"http.response.start\" : headers = MutableHeaders ( scope = message ) for key , value in self . headers : headers . append ( key , value ) await send ( message ) await self . app ( scope , receive , send_with_extra_headers ) See also asgi-logger for an example that inspects the HTTP response and logs a configurable HTTP access log line. Likewise, WebSocket middleware may manipulate websocket.send ASGI event messages to inspect or alter outgoing WebSocket data. Note that if you change the response body, you will need to update the response Content-Length header to match the new response body length. See brotli-asgi for a complete example.","title":"Inspecting or modifying the response"},{"location":"middleware/#passing-information-to-endpoints","text":"If you need to share information with the underlying app or endpoints, you may store it into the scope dictionary. Note that this is a convention -- for example, Starlette uses this to share routing information with endpoints -- but it is not part of the ASGI specification. If you do so, be sure to avoid conflicts by using keys that have low chances of being used by other middleware or applications. For example, when including the middleware below, endpoints would be able to access request.scope[\"asgi_transaction_id\"] . import uuid class TransactionIDMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): scope [ \"asgi_transaction_id\" ] = uuid . uuid4 () await self . app ( scope , receive , send )","title":"Passing information to endpoints"},{"location":"middleware/#cleanup-and-error-handling","text":"You can wrap the application in a try/except/finally block or a context manager to perform cleanup operations or do error handling. For example, the following middleware might collect metrics and process application exceptions... import time class MonitoringMiddleware : def __init__ ( self , app ): self . app = app async def __call__ ( self , scope , receive , send ): start = time . time () try : await self . app ( scope , receive , send ) except Exception as exc : ... # Process the exception raise finally : end = time . time () elapsed = end - start ... # Submit `elapsed` as a metric to a monitoring backend See also timing-asgi for a full example of this pattern.","title":"Cleanup and error handling"},{"location":"middleware/#gotchas","text":"","title":"Gotchas"},{"location":"middleware/#asgi-middleware-should-be-stateless","text":"Because ASGI is designed to handle concurrent requests, any connection-specific state should be scoped to the __call__ implementation. Not doing so would typically lead to conflicting variable reads/writes across requests, and most likely bugs. As an example, this would conditionally replace the response body, if an X-Mock header is present in the response... \u2705 Do \u274c Don't from starlette.datastructures import Headers class MockResponseBodyMiddleware : def __init__ ( self , app , content ): self . app = app self . content = content async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return # A flag that we will turn `True` if the HTTP response # has the 'X-Mock' header. # \u2705: Scoped to this function. should_mock = False async def maybe_send_with_mock_content ( message ): nonlocal should_mock if message [ \"type\" ] == \"http.response.start\" : headers = Headers ( raw = message [ \"headers\" ]) should_mock = headers . get ( \"X-Mock\" ) == \"1\" await send ( message ) elif message [ \"type\" ] == \"http.response.body\" : if should_mock : message = { \"type\" : \"http.response.body\" , \"body\" : self . content } await send ( message ) await self . app ( scope , receive , maybe_send_with_mock_content ) from starlette.datastructures import Headers class MockResponseBodyMiddleware : def __init__ ( self , app , content ): self . app = app self . content = content # \u274c: This variable would be read and written across requests! self . should_mock = False async def __call__ ( self , scope , receive , send ): if scope [ \"type\" ] != \"http\" : await self . app ( scope , receive , send ) return async def maybe_send_with_mock_content ( message ): if message [ \"type\" ] == \"http.response.start\" : headers = Headers ( raw = message [ \"headers\" ]) self . should_mock = headers . get ( \"X-Mock\" ) == \"1\" await send ( message ) elif message [ \"type\" ] == \"http.response.body\" : if self . should_mock : message = { \"type\" : \"http.response.body\" , \"body\" : self . content } await send ( message ) await self . app ( scope , receive , maybe_send_with_mock_content ) See also GZipMiddleware for a full example implementation that navigates this potential gotcha.","title":"ASGI middleware should be stateless"},{"location":"middleware/#further-reading","text":"This documentation should be enough to have a good basis on how to create an ASGI middleware. Nonetheless, there are great articles about the subject: Introduction to ASGI: Emergence of an Async Python Web Ecosystem How to write ASGI middleware","title":"Further reading"},{"location":"middleware/#using-middleware-in-other-frameworks","text":"To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance: app = TrustedHostMiddleware ( app , allowed_hosts = [ 'example.com' ]) You can do this with a Starlette application instance too, but it is preferable to use the middleware=<List of Middleware instances> style, as it will: Ensure that everything remains wrapped in a single outermost ServerErrorMiddleware . Preserves the top-level app instance.","title":"Using middleware in other frameworks"},{"location":"middleware/#applying-middleware-to-mounts","text":"Middleware can also be added to Mount , which allows you to apply middleware to a single route, a group of routes or any mounted ASGI application: from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.gzip import GZipMiddleware from starlette.routing import Mount , Route routes = [ Mount ( \"/\" , routes = [ Route ( \"/example\" , endpoint =... , ) ], middleware = [ Middleware ( GZipMiddleware )] ) ] app = Starlette ( routes = routes ) Note that middleware used in this way is not wrapped in exception handling middleware like the middleware applied to the Starlette application is. This is often not a problem because it only applies to middleware that inspect or modify the Response , and even then you probably don't want to apply this logic to error responses. If you do want to apply the middleware logic to error responses only on some routes you have a couple of options: Add an ExceptionMiddleware onto the Mount Add a try/except block to your middleware and return an error response from there Split up marking and processing into two middlewares, one that gets put on Mount which marks the response as needing processing (for example by setting scope[\"log-response\"] = True ) and another applied to the Starlette application that does the heavy lifting.","title":"Applying middleware to Mounts"},{"location":"middleware/#third-party-middleware","text":"","title":"Third party middleware"},{"location":"middleware/#asgi-auth-github","text":"This middleware adds authentication to any ASGI application, requiring users to sign in using their GitHub account (via OAuth ). Access can be restricted to specific users or to members of specific GitHub organizations or teams.","title":"asgi-auth-github"},{"location":"middleware/#asgi-csrf","text":"Middleware for protecting against CSRF attacks. This middleware implements the Double Submit Cookie pattern, where a cookie is set, then it is compared to a csrftoken hidden form field or an x-csrftoken HTTP header.","title":"asgi-csrf"},{"location":"middleware/#authlibmiddleware","text":"A drop-in replacement for Starlette session middleware, using authlib's jwt module.","title":"AuthlibMiddleware"},{"location":"middleware/#bugsnagmiddleware","text":"A middleware class for logging exceptions to Bugsnag .","title":"BugsnagMiddleware"},{"location":"middleware/#csrfmiddleware","text":"Middleware for protecting against CSRF attacks. This middleware implements the Double Submit Cookie pattern, where a cookie is set, then it is compared to an x-csrftoken HTTP header.","title":"CSRFMiddleware"},{"location":"middleware/#earlydatamiddleware","text":"Middleware and decorator for detecting and denying TLSv1.3 early data requests.","title":"EarlyDataMiddleware"},{"location":"middleware/#prometheusmiddleware","text":"A middleware class for capturing Prometheus metrics related to requests and responses, including in progress requests, timing...","title":"PrometheusMiddleware"},{"location":"middleware/#proxyheadersmiddleware","text":"Uvicorn includes a middleware class for determining the client IP address, when proxy servers are being used, based on the X-Forwarded-Proto and X-Forwarded-For headers. For more complex proxy configurations, you might want to adapt this middleware.","title":"ProxyHeadersMiddleware"},{"location":"middleware/#ratelimitmiddleware","text":"A rate limit middleware. Regular expression matches url; flexible rules; highly customizable. Very easy to use.","title":"RateLimitMiddleware"},{"location":"middleware/#requestidmiddleware","text":"A middleware class for reading/generating request IDs and attaching them to application logs.","title":"RequestIdMiddleware"},{"location":"middleware/#rollbarmiddleware","text":"A middleware class for logging exceptions, errors, and log messages to Rollbar .","title":"RollbarMiddleware"},{"location":"middleware/#sentrymiddleware","text":"A middleware class for logging exceptions to Sentry .","title":"SentryMiddleware"},{"location":"middleware/#starletteopentracing","text":"A middleware class that emits tracing info to OpenTracing.io compatible tracers and can be used to profile and monitor distributed applications.","title":"StarletteOpentracing"},{"location":"middleware/#timingmiddleware","text":"A middleware class to emit timing information (cpu and wall time) for each request which passes through it. Includes examples for how to emit these timings as statsd metrics.","title":"TimingMiddleware"},{"location":"middleware/#wsgimiddleware","text":"A middleware class in charge of converting a WSGI application into an ASGI one.","title":"WSGIMiddleware"},{"location":"release-notes/","text":"0.23.1 December 9, 2022 Fixed Only stop receiving stream on body_stream if body is empty on the BaseHTTPMiddleware #1940 . 0.23.0 December 5, 2022 Added Add headers parameter to the TestClient #1966 . Deprecated Deprecate Starlette and Router decorators #1897 . Fixed Fix bug on FloatConvertor regex #1973 . 0.22.0 November 17, 2022 Changed Bypass GZipMiddleware when response includes Content-Encoding #1901 . Fixed Remove unneeded unquote() from query parameters on the TestClient #1953 . Make sure MutableHeaders._list is actually a list #1917 . Import compatibility with the next version of AnyIO #1936 . 0.21.0 September 26, 2022 This release replaces the underlying HTTP client used on the TestClient ( requests :arrow_right: httpx ), and as those clients differ a bit on their API , your test suite will likely break. To make the migration smoother, you can use the bump-testclient tool. Changed Replace requests with httpx in TestClient #1376 . Added Add WebSocketException and support for WebSocket exception handlers #1263 . Add middleware parameter to Mount class #1649 . Officially support Python 3.11 1863 . Implement __repr__ for route classes #1864 . Fixed Fix bug on which BackgroundTasks were cancelled when using BaseHTTPMiddleware and client disconnected #1715 . 0.20.4 June 28, 2022 Fixed Remove converter from path when generating OpenAPI schema #1648 . 0.20.3 June 10, 2022 Fixed Revert \"Allow StaticFiles to follow symlinks\" #1681 . 0.20.2 June 7, 2022 Fixed Fix regression on route paths with colons #1675 . Allow StaticFiles to follow symlinks #1337 . 0.20.1 May 28, 2022 Fixed Improve detection of async callables #1444 . Send 400 (Bad Request) when boundary is missing #1617 . Send 400 (Bad Request) when missing \"name\" field on Content-Disposition header #1643 . Do not send empty data to StreamingResponse on BaseHTTPMiddleware #1609 . Add __bool__ dunder for Secret #1625 . 0.20.0 May 3, 2022 Removed Drop Python 3.6 support #1357 and #1616 . 0.19.1 April 22, 2022 Fixed Fix inference of Route.name when created from methods #1553 . Avoid TypeError on websocket.disconnect when code is None #1574 . Deprecated Deprecate WS_1004_NO_STATUS_RCVD and WS_1005_ABNORMAL_CLOSURE in favor of WS_1005_NO_STATUS_RCVD and WS_1006_ABNORMAL_CLOSURE , as the previous constants didn't match the WebSockets specs #1580 . 0.19.0 March 9, 2022 Added Error handler will always run, even if the error happens on a background task #761 . Add headers parameter to HTTPException #1435 . Internal responses with 405 status code insert an Allow header, as described by RFC 7231 #1436 . The content argument in JSONResponse is now required #1431 . Add custom URL convertor register #1437 . Add content disposition type parameter to FileResponse #1266 . Add next query param with original request URL in requires decorator #920 . Add raw_path to TestClient scope #1445 . Add union operators to MutableHeaders #1240 . Display missing route details on debug page #1363 . Change anyio required version range to >=3.4.0,<5.0 #1421 and #1460 . Add typing-extensions>=3.10 requirement - used only on lower versions than Python 3.10 #1475 . Fixed Prevent BaseHTTPMiddleware from hiding errors of StreamingResponse and mounted applications #1459 . SessionMiddleware uses an explicit path=... , instead of defaulting to the ASGI 'root_path' #1512 . Request.client is now compliant with the ASGI specifications #1462 . Raise KeyError at early stage for missing boundary #1349 . Deprecated Deprecate WSGIMiddleware in favor of a2wsgi #1504 . Deprecate run_until_first_complete #1443 . 0.18.0 January 23, 2022 Added Change default chunk size from 4Kb to 64Kb on FileResponse #1345 . Add support for functools.partial in WebSocketRoute #1356 . Add StaticFiles packages with directory #1350 . Allow environment options in Jinja2Templates #1401 . Allow HEAD method on HttpEndpoint #1346 . Accept additional headers on websocket.accept message #1361 and #1422 . Add reason to WebSocket close ASGI event #1417 . Add headers attribute to UploadFile #1382 . Don't omit Content-Length header for Content-Length: 0 cases #1395 . Don't set headers for responses with 1xx, 204 and 304 status code #1397 . SessionMiddleware.max_age now accepts None , so cookie can last as long as the browser session #1387 . Fixed Tweak hashlib.md5() function on FileResponse s ETag generation. The parameter usedforsecurity flag is set to False , if the flag is available on the system. This fixes an error raised on systems with FIPS enabled #1366 and #1410 . Fix path_params type on url_path_for() method i.e. turn str into Any #1341 . Host now ignores port on routing #1322 . 0.17.1 November 17, 2021 Fixed Fix IndexError in authentication requires when wrapped function arguments are distributed between *args and **kwargs #1335 . 0.17.0 November 4, 2021 Added Response.delete_cookie now accepts the same parameters as Response.set_cookie #1228 . Update the Jinja2Templates constructor to allow PathLike #1292 . Fixed Fix BadSignature exception handling in SessionMiddleware #1264 . Change HTTPConnection.__getitem__ return type from str to typing.Any #1118 . Change ImmutableMultiDict.getlist return type from typing.List[str] to typing.List[typing.Any] #1235 . Handle OSError exceptions on StaticFiles #1220 . Fix StaticFiles 404.html in HTML mode #1314 . Prevent anyio.ExceptionGroup in error views under a BaseHTTPMiddleware #1262 . Removed Remove GraphQL support #1198 . 0.16.0 July 19, 2021 Added Added Encode funding option #1219 Fixed starlette.websockets.WebSocket instances are now hashable and compare by identity #1039 A number of fixes related to running task groups in lifespan #1213 , #1227 Deprecated/removed The method starlette.templates.Jinja2Templates.get_env was removed #1218 The ClassVar starlette.testclient.TestClient.async_backend was removed, the backend is now configured using constructor kwargs #1211 Passing an Async Generator Function or a Generator Function to starlette.routing.Router(lifespan=) is deprecated. You should wrap your lifespan in @contextlib.asynccontextmanager . #1227 #1110 0.15.0 June 23, 2021 This release includes major changes to the low-level asynchronous parts of Starlette. As a result, Starlette now depends on AnyIO and some minor API changes have occurred. Another significant change with this release is the deprecation of built-in GraphQL support . Added Starlette now supports Trio as an async runtime via AnyIO - #1157 . TestClient.websocket_connect() now must be used as a context manager. Initial support for Python 3.10 - #1201 . The compression level used in GZipMiddleware is now adjustable - #1128 . Fixed Several fixes to CORSMiddleware . See #1111 , #1112 , #1113 , #1199 . Improved exception messages in the case of duplicated path parameter names - #1177 . RedirectResponse now uses quote instead of quote_plus encoding for the Location header to better match the behaviour in other frameworks such as Django - #1164 . Exception causes are now preserved in more cases - #1158 . Session cookies now use the ASGI root path in the case of mounted applications - #1147 . Fixed a cache invalidation bug when static files were deleted in certain circumstances - #1023 . Improved memory usage of BaseHTTPMiddleware when handling large responses - #1012 fixed via #1157 Deprecated/removed Built-in GraphQL support via the GraphQLApp class has been deprecated and will be removed in a future release. Please see #619 . GraphQL is not supported on Python 3.10. The executor parameter to GraphQLApp was removed. Use executor_class instead. The workers parameter to WSGIMiddleware was removed. This hasn't had any effect since Starlette v0.6.3. 0.14.2 February 2, 2021 Fixed Fixed ServerErrorMiddleware compatibility with Python 3.9.1/3.8.7 when debug mode is enabled - #1132 . Fixed unclosed socket ResourceWarning s when using the TestClient with WebSocket endpoints - #1132. Improved detection of async endpoints wrapped in functools.partial on Python 3.8+ - #1106 . 0.14.1 November 9th, 2020 Removed UJSONResponse was removed (this change was intended to be included in 0.14.0). Please see the documentation for how to implement responses using custom JSON serialization - #1074 . 0.14.0 November 8th, 2020 Added Starlette now officially supports Python3.9. In StreamingResponse , allow custom async iterator such as objects from classes implementing __aiter__ . Allow usage of functools.partial async handlers in Python versions 3.6 and 3.7. Add 418 I'm A Teapot status code. Changed Create tasks from handler coroutines before sending them to asyncio.wait . Use format_exception instead of format_tb in ServerErrorMiddleware 's debug responses. Be more lenient with handler arguments when using the requires decorator. 0.13.8 Revert Queue(maxsize=1) fix for BaseHTTPMiddleware middleware classes and streaming responses. The StaticFiles constructor now allows pathlib.Path in addition to strings for its directory argument. 0.13.7 Fix high memory usage when using BaseHTTPMiddleware middleware classes and streaming responses. 0.13.6 Fix 404 errors with StaticFiles . 0.13.5 Add support for Starlette(lifespan=...) functions. More robust path-traversal check in StaticFiles app. Fix WSGI PATH_INFO encoding. RedirectResponse now accepts optional background parameter Allow path routes to contain regex meta characters Treat ASGI HTTP 'body' as an optional key. Don't use thread pooling for writing to in-memory upload files. 0.13.0 Switch to promoting application configuration on init style everywhere. This means dropping the decorator style in favour of declarative routing tables and middleware definitions. 0.12.12 Fix request.url_for() for the Mount-within-a-Mount case. 0.12.11 Fix request.url_for() when an ASGI root_path is being used. 0.12.1 Add URL.include_query_params(**kwargs) Add URL.replace_query_params(**kwargs) Add URL.remove_query_params(param_names) request.state properly persisting across middleware. Added request.scope interface. 0.12.0 Switch to ASGI 3.0. Fixes to CORS middleware. Add StaticFiles(html=True) support. Fix path quoting in redirect responses. 0.11.1 Add request.state interface, for storing arbitrary additional information. Support disabling GraphiQL with GraphQLApp(..., graphiql=False) . 0.11.0 DatabaseMiddleware is now dropped in favour of databases Templates are no longer configured on the application instance. Use templates = Jinja2Templates(directory=...) and return templates.TemplateResponse('index.html', {\"request\": request}) Schema generation is no longer attached to the application instance. Use schemas = SchemaGenerator(...) and return schemas.OpenAPIResponse(request=request) LifespanMiddleware is dropped in favor of router-based lifespan handling. Application instances now accept a routes argument, Starlette(routes=[...]) Schema generation now includes mounted routes. 0.10.6 Add Lifespan routing component. 0.10.5 Ensure templating does not strictly require jinja2 to be installed. 0.10.4 Templates are now configured independently from the application instance. templates = Jinja2Templates(directory=...) . Existing API remains in place, but is no longer documented, and will be deprecated in due course. See the template documentation for more details. 0.10.3 Move to independent databases package instead of DatabaseMiddleware . Existing API remains in place, but is no longer documented, and will be deprecated in due course. 0.10.2 Don't drop explicit port numbers on redirects from HTTPSRedirectMiddleware . 0.10.1 Add MySQL database support. Add host-based routing. 0.10.0 WebSockets now default to sending/receiving JSON over text data frames. Use .send_json(data, mode=\"binary\") and .receive_json(mode=\"binary\") for binary framing. GraphQLApp now takes an executor_class argument, which should be used in preference to the existing executor argument. Resolves an issue with async executors being instantiated before the event loop was setup. The executor argument is expected to be deprecated in the next median or major release. Authentication and the @requires decorator now support WebSocket endpoints. MultiDict and ImmutableMultiDict classes are available in uvicorn.datastructures . QueryParams is now instantiated with standard dict-style *args, **kwargs arguments. 0.9.11 Session cookies now include browser 'expires', in addition to the existing signed expiry. request.form() now returns a multi-dict interface. The query parameter multi-dict implementation now mirrors dict more correctly for the behavior of .keys() , .values() , and .items() when multiple same-key items occur. Use urlsplit throughout in favor of urlparse . 0.9.10 Support @requires(...) on class methods. Apply URL escaping to form data. Support HEAD requests automatically. Add await request.is_disconnected() . Pass operationName to GraphQL executor. 0.9.9 Add TemplateResponse . Add CommaSeparatedStrings datatype. Add BackgroundTasks for multiple tasks. Common subclass for Request and WebSocket , to eg. share session functionality. Expose remote address with request.client . 0.9.8 Add request.database.executemany . 0.9.7 Ensure that AuthenticationMiddleware handles lifespan messages correctly. 0.9.6 Add AuthenticationMiddleware , and @requires() decorator. 0.9.5 Support either str or Secret for SessionMiddleware(secret_key=...) . 0.9.4 Add config.environ . Add datastructures.Secret . Add datastructures.DatabaseURL . 0.9.3 Add config.Config(\".env\") 0.9.2 Add optional database support. Add request to GraphQL context. Hide any password component in URL.__repr__ . 0.9.1 Handle startup/shutdown errors properly. 0.9.0 TestClient can now be used as a context manager, instead of LifespanContext . Lifespan is now handled as middleware. Startup and Shutdown events are visible throughout the middleware stack. 0.8.8 Better support for third-party API schema generators. 0.8.7 Support chunked requests with TestClient. Cleanup asyncio tasks properly with WSGIMiddleware. Support using TestClient within endpoints, for service mocking. 0.8.6 Session cookies are now set on the root path. 0.8.5 Support URL convertors. Support HTTP 304 cache responses from StaticFiles . Resolve character escaping issue with form data. 0.8.4 Default to empty body on responses. 0.8.3 Add 'name' argument to @app.route() . Use 'Host' header for URL reconstruction. 0.8.2 StaticFiles StaticFiles no longer reads the file for responses to HEAD requests. 0.8.1 Templating Add a default templating configuration with Jinja2. Allows the following: app = Starlette ( template_directory = \"templates\" ) @app . route ( '/' ) async def homepage ( request ): # `url_for` is available inside the template. template = app . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content ) 0.8.0 Exceptions Add support for @app.exception_handler(404) . Ensure handled exceptions are not seen as errors by the middleware stack. SessionMiddleware Add max_age , and use timestamp-signed cookies. Defaults to two weeks. Cookies Ensure cookies are strictly HTTP correct. StaticFiles Check directory exists on instantiation. 0.7.4 Concurrency Add starlette.concurrency.run_in_threadpool . Now handles contextvar support. 0.7.3 Routing Add name= support to app.mount() . This allows eg: app.mount('/static', StaticFiles(directory='static'), name='static') . 0.7.2 Middleware Add support for @app.middleware(\"http\") decorator. Routing Add \"endpoint\" to ASGI scope. 0.7.1 Debug tracebacks Improve debug traceback information & styling. URL routing Support mounted URL lookups with \"path=\", eg. url_for('static', path=...) . Support nested URL lookups, eg. url_for('admin:user', username=...) . Add redirect slashes support. Add www redirect support. Background tasks Add background task support to FileResponse and StreamingResponse . 0.7.0 API Schema support Add app.schema_generator = SchemaGenerator(...) . Add app.schema property. Add OpenAPIResponse(...) . GraphQL routing Drop app.add_graphql_route(\"/\", ...) in favor of more consistent app.add_route(\"/\", GraphQLApp(...)) . 0.6.3 Routing API Support routing to methods. Ensure url_path_for works with Mount('/{some_path_params}'). Fix Router(default=) argument. Support repeated paths, like: @app.route(\"/\", methods=[\"GET\"]) , @app.route(\"/\", methods=[\"POST\"]) Use the default ThreadPoolExecutor for all sync endpoints. 0.6.2 SessionMiddleware Added support for request.session , with SessionMiddleware . 0.6.1 BaseHTTPMiddleware Added support for BaseHTTPMiddleware , which provides a standard request/response interface over a regular ASGI middleware. This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly. from starlette.applications import Starlette from starlette.middleware.base import BaseHTTPMiddleware class CustomMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom-Header' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomMiddleware ) 0.6.0 request.path_params The biggest change in 0.6 is that endpoint signatures are no longer: async def func ( request : Request , ** kwargs ) -> Response Instead we just use: async def func ( request : Request ) -> Response The path parameters are available on the request as request.path_params . This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through. request.url_for() Request and WebSocketSession now support URL reversing with request.url_for(name, **path_params) . This method returns a fully qualified URL instance. The URL instance is a string-like object. app.url_path_for() Applications now support URL path reversing with app.url_path_for(name, **path_params) . This method returns a URL instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string. app.routes Applications now support a .routes parameter, which returns a list of [Route|WebSocketRoute|Mount] . Route, WebSocketRoute, Mount The low level components to Router now match the @app.route() , @app.websocket_route() , and app.mount() signatures.","title":"Release Notes"},{"location":"release-notes/#0231","text":"December 9, 2022","title":"0.23.1"},{"location":"release-notes/#fixed","text":"Only stop receiving stream on body_stream if body is empty on the BaseHTTPMiddleware #1940 .","title":"Fixed"},{"location":"release-notes/#0230","text":"December 5, 2022","title":"0.23.0"},{"location":"release-notes/#added","text":"Add headers parameter to the TestClient #1966 .","title":"Added"},{"location":"release-notes/#deprecated","text":"Deprecate Starlette and Router decorators #1897 .","title":"Deprecated"},{"location":"release-notes/#fixed_1","text":"Fix bug on FloatConvertor regex #1973 .","title":"Fixed"},{"location":"release-notes/#0220","text":"November 17, 2022","title":"0.22.0"},{"location":"release-notes/#changed","text":"Bypass GZipMiddleware when response includes Content-Encoding #1901 .","title":"Changed"},{"location":"release-notes/#fixed_2","text":"Remove unneeded unquote() from query parameters on the TestClient #1953 . Make sure MutableHeaders._list is actually a list #1917 . Import compatibility with the next version of AnyIO #1936 .","title":"Fixed"},{"location":"release-notes/#0210","text":"September 26, 2022 This release replaces the underlying HTTP client used on the TestClient ( requests :arrow_right: httpx ), and as those clients differ a bit on their API , your test suite will likely break. To make the migration smoother, you can use the bump-testclient tool.","title":"0.21.0"},{"location":"release-notes/#changed_1","text":"Replace requests with httpx in TestClient #1376 .","title":"Changed"},{"location":"release-notes/#added_1","text":"Add WebSocketException and support for WebSocket exception handlers #1263 . Add middleware parameter to Mount class #1649 . Officially support Python 3.11 1863 . Implement __repr__ for route classes #1864 .","title":"Added"},{"location":"release-notes/#fixed_3","text":"Fix bug on which BackgroundTasks were cancelled when using BaseHTTPMiddleware and client disconnected #1715 .","title":"Fixed"},{"location":"release-notes/#0204","text":"June 28, 2022","title":"0.20.4"},{"location":"release-notes/#fixed_4","text":"Remove converter from path when generating OpenAPI schema #1648 .","title":"Fixed"},{"location":"release-notes/#0203","text":"June 10, 2022","title":"0.20.3"},{"location":"release-notes/#fixed_5","text":"Revert \"Allow StaticFiles to follow symlinks\" #1681 .","title":"Fixed"},{"location":"release-notes/#0202","text":"June 7, 2022","title":"0.20.2"},{"location":"release-notes/#fixed_6","text":"Fix regression on route paths with colons #1675 . Allow StaticFiles to follow symlinks #1337 .","title":"Fixed"},{"location":"release-notes/#0201","text":"May 28, 2022","title":"0.20.1"},{"location":"release-notes/#fixed_7","text":"Improve detection of async callables #1444 . Send 400 (Bad Request) when boundary is missing #1617 . Send 400 (Bad Request) when missing \"name\" field on Content-Disposition header #1643 . Do not send empty data to StreamingResponse on BaseHTTPMiddleware #1609 . Add __bool__ dunder for Secret #1625 .","title":"Fixed"},{"location":"release-notes/#0200","text":"May 3, 2022","title":"0.20.0"},{"location":"release-notes/#removed","text":"Drop Python 3.6 support #1357 and #1616 .","title":"Removed"},{"location":"release-notes/#0191","text":"April 22, 2022","title":"0.19.1"},{"location":"release-notes/#fixed_8","text":"Fix inference of Route.name when created from methods #1553 . Avoid TypeError on websocket.disconnect when code is None #1574 .","title":"Fixed"},{"location":"release-notes/#deprecated_1","text":"Deprecate WS_1004_NO_STATUS_RCVD and WS_1005_ABNORMAL_CLOSURE in favor of WS_1005_NO_STATUS_RCVD and WS_1006_ABNORMAL_CLOSURE , as the previous constants didn't match the WebSockets specs #1580 .","title":"Deprecated"},{"location":"release-notes/#0190","text":"March 9, 2022","title":"0.19.0"},{"location":"release-notes/#added_2","text":"Error handler will always run, even if the error happens on a background task #761 . Add headers parameter to HTTPException #1435 . Internal responses with 405 status code insert an Allow header, as described by RFC 7231 #1436 . The content argument in JSONResponse is now required #1431 . Add custom URL convertor register #1437 . Add content disposition type parameter to FileResponse #1266 . Add next query param with original request URL in requires decorator #920 . Add raw_path to TestClient scope #1445 . Add union operators to MutableHeaders #1240 . Display missing route details on debug page #1363 . Change anyio required version range to >=3.4.0,<5.0 #1421 and #1460 . Add typing-extensions>=3.10 requirement - used only on lower versions than Python 3.10 #1475 .","title":"Added"},{"location":"release-notes/#fixed_9","text":"Prevent BaseHTTPMiddleware from hiding errors of StreamingResponse and mounted applications #1459 . SessionMiddleware uses an explicit path=... , instead of defaulting to the ASGI 'root_path' #1512 . Request.client is now compliant with the ASGI specifications #1462 . Raise KeyError at early stage for missing boundary #1349 .","title":"Fixed"},{"location":"release-notes/#deprecated_2","text":"Deprecate WSGIMiddleware in favor of a2wsgi #1504 . Deprecate run_until_first_complete #1443 .","title":"Deprecated"},{"location":"release-notes/#0180","text":"January 23, 2022","title":"0.18.0"},{"location":"release-notes/#added_3","text":"Change default chunk size from 4Kb to 64Kb on FileResponse #1345 . Add support for functools.partial in WebSocketRoute #1356 . Add StaticFiles packages with directory #1350 . Allow environment options in Jinja2Templates #1401 . Allow HEAD method on HttpEndpoint #1346 . Accept additional headers on websocket.accept message #1361 and #1422 . Add reason to WebSocket close ASGI event #1417 . Add headers attribute to UploadFile #1382 . Don't omit Content-Length header for Content-Length: 0 cases #1395 . Don't set headers for responses with 1xx, 204 and 304 status code #1397 . SessionMiddleware.max_age now accepts None , so cookie can last as long as the browser session #1387 .","title":"Added"},{"location":"release-notes/#fixed_10","text":"Tweak hashlib.md5() function on FileResponse s ETag generation. The parameter usedforsecurity flag is set to False , if the flag is available on the system. This fixes an error raised on systems with FIPS enabled #1366 and #1410 . Fix path_params type on url_path_for() method i.e. turn str into Any #1341 . Host now ignores port on routing #1322 .","title":"Fixed"},{"location":"release-notes/#0171","text":"November 17, 2021","title":"0.17.1"},{"location":"release-notes/#fixed_11","text":"Fix IndexError in authentication requires when wrapped function arguments are distributed between *args and **kwargs #1335 .","title":"Fixed"},{"location":"release-notes/#0170","text":"November 4, 2021","title":"0.17.0"},{"location":"release-notes/#added_4","text":"Response.delete_cookie now accepts the same parameters as Response.set_cookie #1228 . Update the Jinja2Templates constructor to allow PathLike #1292 .","title":"Added"},{"location":"release-notes/#fixed_12","text":"Fix BadSignature exception handling in SessionMiddleware #1264 . Change HTTPConnection.__getitem__ return type from str to typing.Any #1118 . Change ImmutableMultiDict.getlist return type from typing.List[str] to typing.List[typing.Any] #1235 . Handle OSError exceptions on StaticFiles #1220 . Fix StaticFiles 404.html in HTML mode #1314 . Prevent anyio.ExceptionGroup in error views under a BaseHTTPMiddleware #1262 .","title":"Fixed"},{"location":"release-notes/#removed_1","text":"Remove GraphQL support #1198 .","title":"Removed"},{"location":"release-notes/#0160","text":"July 19, 2021","title":"0.16.0"},{"location":"release-notes/#added_5","text":"Added Encode funding option #1219","title":"Added"},{"location":"release-notes/#fixed_13","text":"starlette.websockets.WebSocket instances are now hashable and compare by identity #1039 A number of fixes related to running task groups in lifespan #1213 , #1227","title":"Fixed"},{"location":"release-notes/#deprecatedremoved","text":"The method starlette.templates.Jinja2Templates.get_env was removed #1218 The ClassVar starlette.testclient.TestClient.async_backend was removed, the backend is now configured using constructor kwargs #1211 Passing an Async Generator Function or a Generator Function to starlette.routing.Router(lifespan=) is deprecated. You should wrap your lifespan in @contextlib.asynccontextmanager . #1227 #1110","title":"Deprecated/removed"},{"location":"release-notes/#0150","text":"June 23, 2021 This release includes major changes to the low-level asynchronous parts of Starlette. As a result, Starlette now depends on AnyIO and some minor API changes have occurred. Another significant change with this release is the deprecation of built-in GraphQL support .","title":"0.15.0"},{"location":"release-notes/#added_6","text":"Starlette now supports Trio as an async runtime via AnyIO - #1157 . TestClient.websocket_connect() now must be used as a context manager. Initial support for Python 3.10 - #1201 . The compression level used in GZipMiddleware is now adjustable - #1128 .","title":"Added"},{"location":"release-notes/#fixed_14","text":"Several fixes to CORSMiddleware . See #1111 , #1112 , #1113 , #1199 . Improved exception messages in the case of duplicated path parameter names - #1177 . RedirectResponse now uses quote instead of quote_plus encoding for the Location header to better match the behaviour in other frameworks such as Django - #1164 . Exception causes are now preserved in more cases - #1158 . Session cookies now use the ASGI root path in the case of mounted applications - #1147 . Fixed a cache invalidation bug when static files were deleted in certain circumstances - #1023 . Improved memory usage of BaseHTTPMiddleware when handling large responses - #1012 fixed via #1157","title":"Fixed"},{"location":"release-notes/#deprecatedremoved_1","text":"Built-in GraphQL support via the GraphQLApp class has been deprecated and will be removed in a future release. Please see #619 . GraphQL is not supported on Python 3.10. The executor parameter to GraphQLApp was removed. Use executor_class instead. The workers parameter to WSGIMiddleware was removed. This hasn't had any effect since Starlette v0.6.3.","title":"Deprecated/removed"},{"location":"release-notes/#0142","text":"February 2, 2021","title":"0.14.2"},{"location":"release-notes/#fixed_15","text":"Fixed ServerErrorMiddleware compatibility with Python 3.9.1/3.8.7 when debug mode is enabled - #1132 . Fixed unclosed socket ResourceWarning s when using the TestClient with WebSocket endpoints - #1132. Improved detection of async endpoints wrapped in functools.partial on Python 3.8+ - #1106 .","title":"Fixed"},{"location":"release-notes/#0141","text":"November 9th, 2020","title":"0.14.1"},{"location":"release-notes/#removed_2","text":"UJSONResponse was removed (this change was intended to be included in 0.14.0). Please see the documentation for how to implement responses using custom JSON serialization - #1074 .","title":"Removed"},{"location":"release-notes/#0140","text":"November 8th, 2020","title":"0.14.0"},{"location":"release-notes/#added_7","text":"Starlette now officially supports Python3.9. In StreamingResponse , allow custom async iterator such as objects from classes implementing __aiter__ . Allow usage of functools.partial async handlers in Python versions 3.6 and 3.7. Add 418 I'm A Teapot status code.","title":"Added"},{"location":"release-notes/#changed_2","text":"Create tasks from handler coroutines before sending them to asyncio.wait . Use format_exception instead of format_tb in ServerErrorMiddleware 's debug responses. Be more lenient with handler arguments when using the requires decorator.","title":"Changed"},{"location":"release-notes/#0138","text":"Revert Queue(maxsize=1) fix for BaseHTTPMiddleware middleware classes and streaming responses. The StaticFiles constructor now allows pathlib.Path in addition to strings for its directory argument.","title":"0.13.8"},{"location":"release-notes/#0137","text":"Fix high memory usage when using BaseHTTPMiddleware middleware classes and streaming responses.","title":"0.13.7"},{"location":"release-notes/#0136","text":"Fix 404 errors with StaticFiles .","title":"0.13.6"},{"location":"release-notes/#0135","text":"Add support for Starlette(lifespan=...) functions. More robust path-traversal check in StaticFiles app. Fix WSGI PATH_INFO encoding. RedirectResponse now accepts optional background parameter Allow path routes to contain regex meta characters Treat ASGI HTTP 'body' as an optional key. Don't use thread pooling for writing to in-memory upload files.","title":"0.13.5"},{"location":"release-notes/#0130","text":"Switch to promoting application configuration on init style everywhere. This means dropping the decorator style in favour of declarative routing tables and middleware definitions.","title":"0.13.0"},{"location":"release-notes/#01212","text":"Fix request.url_for() for the Mount-within-a-Mount case.","title":"0.12.12"},{"location":"release-notes/#01211","text":"Fix request.url_for() when an ASGI root_path is being used.","title":"0.12.11"},{"location":"release-notes/#0121","text":"Add URL.include_query_params(**kwargs) Add URL.replace_query_params(**kwargs) Add URL.remove_query_params(param_names) request.state properly persisting across middleware. Added request.scope interface.","title":"0.12.1"},{"location":"release-notes/#0120","text":"Switch to ASGI 3.0. Fixes to CORS middleware. Add StaticFiles(html=True) support. Fix path quoting in redirect responses.","title":"0.12.0"},{"location":"release-notes/#0111","text":"Add request.state interface, for storing arbitrary additional information. Support disabling GraphiQL with GraphQLApp(..., graphiql=False) .","title":"0.11.1"},{"location":"release-notes/#0110","text":"DatabaseMiddleware is now dropped in favour of databases Templates are no longer configured on the application instance. Use templates = Jinja2Templates(directory=...) and return templates.TemplateResponse('index.html', {\"request\": request}) Schema generation is no longer attached to the application instance. Use schemas = SchemaGenerator(...) and return schemas.OpenAPIResponse(request=request) LifespanMiddleware is dropped in favor of router-based lifespan handling. Application instances now accept a routes argument, Starlette(routes=[...]) Schema generation now includes mounted routes.","title":"0.11.0"},{"location":"release-notes/#0106","text":"Add Lifespan routing component.","title":"0.10.6"},{"location":"release-notes/#0105","text":"Ensure templating does not strictly require jinja2 to be installed.","title":"0.10.5"},{"location":"release-notes/#0104","text":"Templates are now configured independently from the application instance. templates = Jinja2Templates(directory=...) . Existing API remains in place, but is no longer documented, and will be deprecated in due course. See the template documentation for more details.","title":"0.10.4"},{"location":"release-notes/#0103","text":"Move to independent databases package instead of DatabaseMiddleware . Existing API remains in place, but is no longer documented, and will be deprecated in due course.","title":"0.10.3"},{"location":"release-notes/#0102","text":"Don't drop explicit port numbers on redirects from HTTPSRedirectMiddleware .","title":"0.10.2"},{"location":"release-notes/#0101","text":"Add MySQL database support. Add host-based routing.","title":"0.10.1"},{"location":"release-notes/#0100","text":"WebSockets now default to sending/receiving JSON over text data frames. Use .send_json(data, mode=\"binary\") and .receive_json(mode=\"binary\") for binary framing. GraphQLApp now takes an executor_class argument, which should be used in preference to the existing executor argument. Resolves an issue with async executors being instantiated before the event loop was setup. The executor argument is expected to be deprecated in the next median or major release. Authentication and the @requires decorator now support WebSocket endpoints. MultiDict and ImmutableMultiDict classes are available in uvicorn.datastructures . QueryParams is now instantiated with standard dict-style *args, **kwargs arguments.","title":"0.10.0"},{"location":"release-notes/#0911","text":"Session cookies now include browser 'expires', in addition to the existing signed expiry. request.form() now returns a multi-dict interface. The query parameter multi-dict implementation now mirrors dict more correctly for the behavior of .keys() , .values() , and .items() when multiple same-key items occur. Use urlsplit throughout in favor of urlparse .","title":"0.9.11"},{"location":"release-notes/#0910","text":"Support @requires(...) on class methods. Apply URL escaping to form data. Support HEAD requests automatically. Add await request.is_disconnected() . Pass operationName to GraphQL executor.","title":"0.9.10"},{"location":"release-notes/#099","text":"Add TemplateResponse . Add CommaSeparatedStrings datatype. Add BackgroundTasks for multiple tasks. Common subclass for Request and WebSocket , to eg. share session functionality. Expose remote address with request.client .","title":"0.9.9"},{"location":"release-notes/#098","text":"Add request.database.executemany .","title":"0.9.8"},{"location":"release-notes/#097","text":"Ensure that AuthenticationMiddleware handles lifespan messages correctly.","title":"0.9.7"},{"location":"release-notes/#096","text":"Add AuthenticationMiddleware , and @requires() decorator.","title":"0.9.6"},{"location":"release-notes/#095","text":"Support either str or Secret for SessionMiddleware(secret_key=...) .","title":"0.9.5"},{"location":"release-notes/#094","text":"Add config.environ . Add datastructures.Secret . Add datastructures.DatabaseURL .","title":"0.9.4"},{"location":"release-notes/#093","text":"Add config.Config(\".env\")","title":"0.9.3"},{"location":"release-notes/#092","text":"Add optional database support. Add request to GraphQL context. Hide any password component in URL.__repr__ .","title":"0.9.2"},{"location":"release-notes/#091","text":"Handle startup/shutdown errors properly.","title":"0.9.1"},{"location":"release-notes/#090","text":"TestClient can now be used as a context manager, instead of LifespanContext . Lifespan is now handled as middleware. Startup and Shutdown events are visible throughout the middleware stack.","title":"0.9.0"},{"location":"release-notes/#088","text":"Better support for third-party API schema generators.","title":"0.8.8"},{"location":"release-notes/#087","text":"Support chunked requests with TestClient. Cleanup asyncio tasks properly with WSGIMiddleware. Support using TestClient within endpoints, for service mocking.","title":"0.8.7"},{"location":"release-notes/#086","text":"Session cookies are now set on the root path.","title":"0.8.6"},{"location":"release-notes/#085","text":"Support URL convertors. Support HTTP 304 cache responses from StaticFiles . Resolve character escaping issue with form data.","title":"0.8.5"},{"location":"release-notes/#084","text":"Default to empty body on responses.","title":"0.8.4"},{"location":"release-notes/#083","text":"Add 'name' argument to @app.route() . Use 'Host' header for URL reconstruction.","title":"0.8.3"},{"location":"release-notes/#082","text":"","title":"0.8.2"},{"location":"release-notes/#staticfiles","text":"StaticFiles no longer reads the file for responses to HEAD requests.","title":"StaticFiles"},{"location":"release-notes/#081","text":"","title":"0.8.1"},{"location":"release-notes/#templating","text":"Add a default templating configuration with Jinja2. Allows the following: app = Starlette ( template_directory = \"templates\" ) @app . route ( '/' ) async def homepage ( request ): # `url_for` is available inside the template. template = app . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content )","title":"Templating"},{"location":"release-notes/#080","text":"","title":"0.8.0"},{"location":"release-notes/#exceptions","text":"Add support for @app.exception_handler(404) . Ensure handled exceptions are not seen as errors by the middleware stack.","title":"Exceptions"},{"location":"release-notes/#sessionmiddleware","text":"Add max_age , and use timestamp-signed cookies. Defaults to two weeks.","title":"SessionMiddleware"},{"location":"release-notes/#cookies","text":"Ensure cookies are strictly HTTP correct.","title":"Cookies"},{"location":"release-notes/#staticfiles_1","text":"Check directory exists on instantiation.","title":"StaticFiles"},{"location":"release-notes/#074","text":"","title":"0.7.4"},{"location":"release-notes/#concurrency","text":"Add starlette.concurrency.run_in_threadpool . Now handles contextvar support.","title":"Concurrency"},{"location":"release-notes/#073","text":"","title":"0.7.3"},{"location":"release-notes/#routing","text":"Add name= support to app.mount() . This allows eg: app.mount('/static', StaticFiles(directory='static'), name='static') .","title":"Routing"},{"location":"release-notes/#072","text":"","title":"0.7.2"},{"location":"release-notes/#middleware","text":"Add support for @app.middleware(\"http\") decorator.","title":"Middleware"},{"location":"release-notes/#routing_1","text":"Add \"endpoint\" to ASGI scope.","title":"Routing"},{"location":"release-notes/#071","text":"","title":"0.7.1"},{"location":"release-notes/#debug-tracebacks","text":"Improve debug traceback information & styling.","title":"Debug tracebacks"},{"location":"release-notes/#url-routing","text":"Support mounted URL lookups with \"path=\", eg. url_for('static', path=...) . Support nested URL lookups, eg. url_for('admin:user', username=...) . Add redirect slashes support. Add www redirect support.","title":"URL routing"},{"location":"release-notes/#background-tasks","text":"Add background task support to FileResponse and StreamingResponse .","title":"Background tasks"},{"location":"release-notes/#070","text":"","title":"0.7.0"},{"location":"release-notes/#api-schema-support","text":"Add app.schema_generator = SchemaGenerator(...) . Add app.schema property. Add OpenAPIResponse(...) .","title":"API Schema support"},{"location":"release-notes/#graphql-routing","text":"Drop app.add_graphql_route(\"/\", ...) in favor of more consistent app.add_route(\"/\", GraphQLApp(...)) .","title":"GraphQL routing"},{"location":"release-notes/#063","text":"","title":"0.6.3"},{"location":"release-notes/#routing-api","text":"Support routing to methods. Ensure url_path_for works with Mount('/{some_path_params}'). Fix Router(default=) argument. Support repeated paths, like: @app.route(\"/\", methods=[\"GET\"]) , @app.route(\"/\", methods=[\"POST\"]) Use the default ThreadPoolExecutor for all sync endpoints.","title":"Routing API"},{"location":"release-notes/#062","text":"","title":"0.6.2"},{"location":"release-notes/#sessionmiddleware_1","text":"Added support for request.session , with SessionMiddleware .","title":"SessionMiddleware"},{"location":"release-notes/#061","text":"","title":"0.6.1"},{"location":"release-notes/#basehttpmiddleware","text":"Added support for BaseHTTPMiddleware , which provides a standard request/response interface over a regular ASGI middleware. This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly. from starlette.applications import Starlette from starlette.middleware.base import BaseHTTPMiddleware class CustomMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom-Header' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomMiddleware )","title":"BaseHTTPMiddleware"},{"location":"release-notes/#060","text":"","title":"0.6.0"},{"location":"release-notes/#requestpath_params","text":"The biggest change in 0.6 is that endpoint signatures are no longer: async def func ( request : Request , ** kwargs ) -> Response Instead we just use: async def func ( request : Request ) -> Response The path parameters are available on the request as request.path_params . This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through.","title":"request.path_params"},{"location":"release-notes/#requesturl_for","text":"Request and WebSocketSession now support URL reversing with request.url_for(name, **path_params) . This method returns a fully qualified URL instance. The URL instance is a string-like object.","title":"request.url_for()"},{"location":"release-notes/#appurl_path_for","text":"Applications now support URL path reversing with app.url_path_for(name, **path_params) . This method returns a URL instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string.","title":"app.url_path_for()"},{"location":"release-notes/#approutes","text":"Applications now support a .routes parameter, which returns a list of [Route|WebSocketRoute|Mount] .","title":"app.routes"},{"location":"release-notes/#route-websocketroute-mount","text":"The low level components to Router now match the @app.route() , @app.websocket_route() , and app.mount() signatures.","title":"Route, WebSocketRoute, Mount"},{"location":"requests/","text":"Starlette includes a Request class that gives you a nicer interface onto the incoming request, rather than accessing the ASGI scope and receive channel directly. Request Signature: Request(scope, receive=None) from starlette.requests import Request from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' request = Request ( scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( scope , receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive . Method The request method is accessed as request.method . URL The request URL is accessed as request.url . The property is a string-like object that exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type'] Query Parameters Query parameters are exposed as an immutable multi-dict. For example: request.query_params['search'] Path Parameters Router path parameters are exposed as a dictionary interface. For example: request.path_params['username'] Client Address The client's remote address is exposed as a named two-tuple request.client . Either item in the tuple may be None . The hostname or IP address: request.client.host The port number from which the client is connecting: request.client.port Cookies Cookies are exposed as a regular dictionary interface. For example: request.cookies.get('mycookie') Cookies are ignored in case of an invalid cookie. (RFC2109) Body There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as form data or multipart: await request.form() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.requests import Request from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' request = Request ( scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( scope , receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() , .form() , or .json() will raise an error. In some cases such as long-polling, or streaming responses you might need to determine if the client has dropped the connection. You can determine this state with disconnected = await request.is_disconnected() . Request Files Request files are normally sent as multipart form data ( multipart/form-data ). When you call await request.form() you receive a starlette.datastructures.FormData which is an immutable multidict, containing both file uploads and text input. File upload items are represented as instances of starlette.datastructures.UploadFile . UploadFile has the following attributes: filename : A str with the original file name that was uploaded (e.g. myimage.jpg ). content_type : A str with the content type (MIME type / media type) (e.g. image/jpeg ). file : A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. headers : A Headers object. Often this will only be the Content-Type header, but if additional headers were included in the multipart field they will be included here. Note that these headers have no relationship with the headers in Request.headers . UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile ). async write(data) : Writes data ( bytes ) to the file. async read(size) : Reads size ( int ) bytes of the file. async seek(offset) : Goes to the byte position offset ( int ) in the file. E.g., await myfile.seek(0) would go to the start of the file. async close() : Closes the file. As all these methods are async methods, you need to \"await\" them. For example, you can get the file name and the contents with: form = await request . form () filename = form [ \"upload_file\" ] . filename contents = await form [ \"upload_file\" ] . read () Info As settled in RFC-7578: 4.2 , form-data content part that contains file assumed to have name and filename fields in Content-Disposition header: Content-Disposition: form-data; name=\"user\"; filename=\"somefile\" . Though filename field is optional according to RFC-7578, it helps Starlette to differentiate which data should be treated as file. If filename field was supplied, UploadFile object will be created to access underlying file, otherwise form-data part will be parsed and available as a raw string. Application The originating Starlette application can be accessed via request.app . Other state If you want to store additional information on the request you can do so using request.state . For example: request.state.time_started = time.time()","title":"Requests"},{"location":"requests/#request","text":"Signature: Request(scope, receive=None) from starlette.requests import Request from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' request = Request ( scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( scope , receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive .","title":"Request"},{"location":"requests/#method","text":"The request method is accessed as request.method .","title":"Method"},{"location":"requests/#url","text":"The request URL is accessed as request.url . The property is a string-like object that exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme .","title":"URL"},{"location":"requests/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type']","title":"Headers"},{"location":"requests/#query-parameters","text":"Query parameters are exposed as an immutable multi-dict. For example: request.query_params['search']","title":"Query Parameters"},{"location":"requests/#path-parameters","text":"Router path parameters are exposed as a dictionary interface. For example: request.path_params['username']","title":"Path Parameters"},{"location":"requests/#client-address","text":"The client's remote address is exposed as a named two-tuple request.client . Either item in the tuple may be None . The hostname or IP address: request.client.host The port number from which the client is connecting: request.client.port","title":"Client Address"},{"location":"requests/#cookies","text":"Cookies are exposed as a regular dictionary interface. For example: request.cookies.get('mycookie') Cookies are ignored in case of an invalid cookie. (RFC2109)","title":"Cookies"},{"location":"requests/#body","text":"There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as form data or multipart: await request.form() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.requests import Request from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' request = Request ( scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( scope , receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() , .form() , or .json() will raise an error. In some cases such as long-polling, or streaming responses you might need to determine if the client has dropped the connection. You can determine this state with disconnected = await request.is_disconnected() .","title":"Body"},{"location":"requests/#request-files","text":"Request files are normally sent as multipart form data ( multipart/form-data ). When you call await request.form() you receive a starlette.datastructures.FormData which is an immutable multidict, containing both file uploads and text input. File upload items are represented as instances of starlette.datastructures.UploadFile . UploadFile has the following attributes: filename : A str with the original file name that was uploaded (e.g. myimage.jpg ). content_type : A str with the content type (MIME type / media type) (e.g. image/jpeg ). file : A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. headers : A Headers object. Often this will only be the Content-Type header, but if additional headers were included in the multipart field they will be included here. Note that these headers have no relationship with the headers in Request.headers . UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile ). async write(data) : Writes data ( bytes ) to the file. async read(size) : Reads size ( int ) bytes of the file. async seek(offset) : Goes to the byte position offset ( int ) in the file. E.g., await myfile.seek(0) would go to the start of the file. async close() : Closes the file. As all these methods are async methods, you need to \"await\" them. For example, you can get the file name and the contents with: form = await request . form () filename = form [ \"upload_file\" ] . filename contents = await form [ \"upload_file\" ] . read () Info As settled in RFC-7578: 4.2 , form-data content part that contains file assumed to have name and filename fields in Content-Disposition header: Content-Disposition: form-data; name=\"user\"; filename=\"somefile\" . Though filename field is optional according to RFC-7578, it helps Starlette to differentiate which data should be treated as file. If filename field was supplied, UploadFile object will be created to access underlying file, otherwise form-data part will be parsed and available as a raw string.","title":"Request Files"},{"location":"requests/#application","text":"The originating Starlette application can be accessed via request.app .","title":"Application"},{"location":"requests/#other-state","text":"If you want to store additional information on the request you can do so using request.state . For example: request.state.time_started = time.time()","title":"Other state"},{"location":"responses/","text":"Starlette includes a few response classes that handle sending back the appropriate ASGI messages on the send channel. Response Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( scope , receive , send ) Set Cookie Starlette provides a set_cookie method to allow you to set cookies on the response object. Signature: Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\") key - A string that will be the cookie's key. value - A string that will be the cookie's value. max_age - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of 0 will discard the cookie immediately. Optional expires - An integer that defines the number of seconds until the cookie expires. Optional path - A string that specifies the subset of routes to which the cookie will apply. Optional domain - A string that specifies the domain for which the cookie is valid. Optional secure - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. Optional httponly - A bool indicating that the cookie cannot be accessed via JavaScript through Document.cookie property, the XMLHttpRequest or Request APIs. Optional samesite - A string that specifies the samesite strategy for the cookie. Valid values are 'lax' , 'strict' and 'none' . Defaults to 'lax' . Optional Delete Cookie Conversly, Starlette also provides a delete_cookie method to manually expire a set cookie. Signature: Response.delete_cookie(key, path='/', domain=None) HTMLResponse Takes some text or bytes and returns an HTML response. from starlette.responses import HTMLResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( scope , receive , send ) PlainTextResponse Takes some text or bytes and returns a plain text response. from starlette.responses import PlainTextResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send ) JSONResponse Takes some data and returns an application/json encoded response. from starlette.responses import JSONResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = JSONResponse ({ 'hello' : 'world' }) await response ( scope , receive , send ) Custom JSON serialization If you need fine-grained control over JSON serialization, you can subclass JSONResponse and override the render method. For example, if you wanted to use a third-party JSON library such as orjson : from typing import Any import orjson from starlette.responses import JSONResponse class OrjsonResponse ( JSONResponse ): def render ( self , content : Any ) -> bytes : return orjson . dumps ( content ) In general you probably want to stick with JSONResponse by default unless you are micro-optimising a particular endpoint or need to serialize non-standard object types. RedirectResponse Returns an HTTP redirect. Uses a 307 status code by default. from starlette.responses import PlainTextResponse , RedirectResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' if scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send ) StreamingResponse Takes an async generator or a normal generator/iterator and streams the response body. from starlette.responses import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( scope , receive , send ) Have in mind that file-like objects (like those created by open() ) are normal iterators. So, you can return them directly in a StreamingResponse . FileResponse Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . content_disposition_type - will be included in the response Content-Disposition . Can be set to \"attachment\" (default) or \"inline\". File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.responses import FileResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = FileResponse ( 'statics/favicon.ico' ) await response ( scope , receive , send ) Third party responses EventSourceResponse A response class that implements Server-Sent Events . It enables event streaming from the server to the client without the complexity of websockets. baize.asgi.FileResponse As a smooth replacement for Starlette FileResponse , it will automatically handle Head method and Range requests .","title":"Responses"},{"location":"responses/#response","text":"Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( scope , receive , send )","title":"Response"},{"location":"responses/#set-cookie","text":"Starlette provides a set_cookie method to allow you to set cookies on the response object. Signature: Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\") key - A string that will be the cookie's key. value - A string that will be the cookie's value. max_age - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of 0 will discard the cookie immediately. Optional expires - An integer that defines the number of seconds until the cookie expires. Optional path - A string that specifies the subset of routes to which the cookie will apply. Optional domain - A string that specifies the domain for which the cookie is valid. Optional secure - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. Optional httponly - A bool indicating that the cookie cannot be accessed via JavaScript through Document.cookie property, the XMLHttpRequest or Request APIs. Optional samesite - A string that specifies the samesite strategy for the cookie. Valid values are 'lax' , 'strict' and 'none' . Defaults to 'lax' . Optional","title":"Set Cookie"},{"location":"responses/#delete-cookie","text":"Conversly, Starlette also provides a delete_cookie method to manually expire a set cookie. Signature: Response.delete_cookie(key, path='/', domain=None)","title":"Delete Cookie"},{"location":"responses/#htmlresponse","text":"Takes some text or bytes and returns an HTML response. from starlette.responses import HTMLResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( scope , receive , send )","title":"HTMLResponse"},{"location":"responses/#plaintextresponse","text":"Takes some text or bytes and returns a plain text response. from starlette.responses import PlainTextResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send )","title":"PlainTextResponse"},{"location":"responses/#jsonresponse","text":"Takes some data and returns an application/json encoded response. from starlette.responses import JSONResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = JSONResponse ({ 'hello' : 'world' }) await response ( scope , receive , send )","title":"JSONResponse"},{"location":"responses/#custom-json-serialization","text":"If you need fine-grained control over JSON serialization, you can subclass JSONResponse and override the render method. For example, if you wanted to use a third-party JSON library such as orjson : from typing import Any import orjson from starlette.responses import JSONResponse class OrjsonResponse ( JSONResponse ): def render ( self , content : Any ) -> bytes : return orjson . dumps ( content ) In general you probably want to stick with JSONResponse by default unless you are micro-optimising a particular endpoint or need to serialize non-standard object types.","title":"Custom JSON serialization"},{"location":"responses/#redirectresponse","text":"Returns an HTTP redirect. Uses a 307 status code by default. from starlette.responses import PlainTextResponse , RedirectResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' if scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send )","title":"RedirectResponse"},{"location":"responses/#streamingresponse","text":"Takes an async generator or a normal generator/iterator and streams the response body. from starlette.responses import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( scope , receive , send ) Have in mind that file-like objects (like those created by open() ) are normal iterators. So, you can return them directly in a StreamingResponse .","title":"StreamingResponse"},{"location":"responses/#fileresponse","text":"Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . content_disposition_type - will be included in the response Content-Disposition . Can be set to \"attachment\" (default) or \"inline\". File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.responses import FileResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = FileResponse ( 'statics/favicon.ico' ) await response ( scope , receive , send )","title":"FileResponse"},{"location":"responses/#third-party-responses","text":"","title":"Third party responses"},{"location":"responses/#eventsourceresponse","text":"A response class that implements Server-Sent Events . It enables event streaming from the server to the client without the complexity of websockets.","title":"EventSourceResponse"},{"location":"responses/#baizeasgifileresponse","text":"As a smooth replacement for Starlette FileResponse , it will automatically handle Head method and Range requests .","title":"baize.asgi.FileResponse"},{"location":"routing/","text":"HTTP Routing Starlette has a simple but capable request routing system. A routing table is defined as a list of routes, and passed when instantiating the application. from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.routing import Route async def homepage ( request ): return PlainTextResponse ( \"Homepage\" ) async def about ( request ): return PlainTextResponse ( \"About\" ) routes = [ Route ( \"/\" , endpoint = homepage ), Route ( \"/about\" , endpoint = about ), ] app = Starlette ( routes = routes ) The endpoint argument can be one of: A regular function or async function, which accepts a single request argument and which should return a response. A class that implements the ASGI interface, such as Starlette's HTTPEndpoint . Path Parameters Paths can use URI templating style to capture path components. Route ( '/users/ {username} ' , user ) By default this will capture characters up to the end of the path or the next / . You can use convertors to modify what is captured. The available convertors are: str returns a string, and is the default. int returns a Python integer. float returns a Python float. uuid return a Python uuid.UUID instance. path returns the rest of the path, including any additional / characters. Convertors are used by prefixing them with a colon, like so: Route ( '/users/{user_id:int}' , user ) Route ( '/floating-point/{number:float}' , floating_point ) Route ( '/uploaded/{rest_of_path:path}' , uploaded ) If you need a different converter that is not defined, you can create your own. See below an example on how to create a datetime convertor, and how to register it: from datetime import datetime from starlette.convertors import Convertor , register_url_convertor class DateTimeConvertor ( Convertor ): regex = \"[0-9] {4} -[0-9] {2} -[0-9] {2} T[0-9] {2} :[0-9] {2} :[0-9] {2} (.[0-9]+)?\" def convert ( self , value : str ) -> datetime : return datetime . strptime ( value , \"%Y-%m- %d T%H:%M:%S\" ) def to_string ( self , value : datetime ) -> str : return value . strftime ( \"%Y-%m- %d T%H:%M:%S\" ) register_url_convertor ( \"datetime\" , DateTimeConvertor ()) After registering it, you'll be able to use it as: Route ( '/history/{date:datetime}' , history ) Path parameters are made available in the request, as the request.path_params dictionary. async def user ( request ): user_id = request . path_params [ 'user_id' ] ... Handling HTTP methods Routes can also specify which HTTP methods are handled by an endpoint: Route ( '/users/{user_id:int}' , user , methods = [ \"GET\" , \"POST\" ]) By default function endpoints will only accept GET requests, unless specified. Submounting routes In large applications you might find that you want to break out parts of the routing table, based on a common path prefix. routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = [ Route ( '/' , users , methods = [ 'GET' , 'POST' ]), Route ( '/ {username} ' , user ), ]) ] This style allows you to define different subsets of the routing table in different parts of your project. from myproject import users , auth routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = users . routes ), Mount ( '/auth' , routes = auth . routes ), ] You can also use mounting to include sub-applications within your Starlette application. For example... # This is a standalone static files server: app = StaticFiles ( directory = \"static\" ) # This is a static files server mounted within a Starlette application, # underneath the \"/static\" path. routes = [ ... Mount ( \"/static\" , app = StaticFiles ( directory = \"static\" ), name = \"static\" ) ] app = Starlette ( routes = routes ) Reverse URL lookups You'll often want to be able to generate the URL for a particular route, such as in cases where you need to return a redirect response. routes = [ Route ( \"/\" , homepage , name = \"homepage\" ) ] # We can use the following to return a URL... url = request . url_for ( \"homepage\" ) URL lookups can include path parameters... routes = [ Route ( \"/users/ {username} \" , user , name = \"user_detail\" ) ] # We can use the following to return a URL... url = request . url_for ( \"user_detail\" , username =... ) If a Mount includes a name , then submounts should use a {prefix}:{name} style for reverse URL lookups. routes = [ Mount ( \"/users\" , name = \"users\" , routes = [ Route ( \"/\" , user , name = \"user_list\" ), Route ( \"/ {username} \" , user , name = \"user_detail\" ) ]) ] # We can use the following to return URLs... url = request . url_for ( \"users:user_list\" ) url = request . url_for ( \"users:user_detail\" , username =... ) Mounted applications may include a path=... parameter. routes = [ ... Mount ( \"/static\" , app = StaticFiles ( directory = \"static\" ), name = \"static\" ) ] # We can use the following to return URLs... url = request . url_for ( \"static\" , path = \"/css/base.css\" ) For cases where there is no request instance, you can make reverse lookups against the application, although these will only return the URL path. url = app . url_path_for ( \"user_detail\" , username =... ) Host-based routing If you want to use different routes for the same path based on the Host header. Note that port is removed from the Host header when matching. For example, Host (host='example.org:3600', ...) will be processed even if the Host header contains or does not contain a port other than 3600 ( example.org:5600 , example.org ). Therefore, you can specify the port if you need it for use in url_for . There are several ways to connect host-based routes to your application site = Router () # Use eg. `@site.route()` to configure this. api = Router () # Use eg. `@api.route()` to configure this. news = Router () # Use eg. `@news.route()` to configure this. routes = [ Host ( 'api.example.org' , api , name = \"site_api\" ) ] app = Starlette ( routes = routes ) app . host ( 'www.example.org' , site , name = \"main_site\" ) news_host = Host ( 'news.example.org' , news ) app . router . routes . append ( news_host ) URL lookups can include host parameters just like path parameters routes = [ Host ( \" {subdomain} .example.org\" , name = \"sub\" , app = Router ( routes = [ Mount ( \"/users\" , name = \"users\" , routes = [ Route ( \"/\" , user , name = \"user_list\" ), Route ( \"/ {username} \" , user , name = \"user_detail\" ) ]) ])) ] ... url = request . url_for ( \"sub:users:user_detail\" , username =... , subdomain =... ) url = request . url_for ( \"sub:users:user_list\" , subdomain =... ) Route priority Incoming paths are matched against each Route in order. In cases where more that one route could match an incoming path, you should take care to ensure that more specific routes are listed before general cases. For example: # Don't do this: `/users/me` will never match incoming requests. routes = [ Route ( '/users/ {username} ' , user ), Route ( '/users/me' , current_user ), ] # Do this: `/users/me` is tested first. routes = [ Route ( '/users/me' , current_user ), Route ( '/users/ {username} ' , user ), ] Working with Router instances If you're working at a low-level you might want to use a plain Router instance, rather that creating a Starlette application. This gives you a lightweight ASGI application that just provides the application routing, without wrapping it up in any middleware. app = Router ( routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = [ Route ( '/' , users , methods = [ 'GET' , 'POST' ]), Route ( '/ {username} ' , user ), ]) ]) WebSocket Routing When working with WebSocket endpoints, you should use WebSocketRoute instead of the usual Route . Path parameters, and reverse URL lookups for WebSocketRoute work the the same as HTTP Route , which can be found in the HTTP Route section above. from starlette.applications import Starlette from starlette.routing import WebSocketRoute async def websocket_index ( websocket ): await websocket . accept () await websocket . send_text ( \"Hello, websocket!\" ) await websocket . close () async def websocket_user ( websocket ): name = websocket . path_params [ \"name\" ] await websocket . accept () await websocket . send_text ( f \"Hello, { name } \" ) await websocket . close () routes = [ WebSocketRoute ( \"/\" , endpoint = websocket_index ), WebSocketRoute ( \"/ {name} \" , endpoint = websocket_user ), ] app = Starlette ( routes = routes ) The endpoint argument can be one of: An async function, which accepts a single websocket argument. A class that implements the ASGI interface, such as Starlette's WebSocketEndpoint .","title":"Routing"},{"location":"routing/#http-routing","text":"Starlette has a simple but capable request routing system. A routing table is defined as a list of routes, and passed when instantiating the application. from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.routing import Route async def homepage ( request ): return PlainTextResponse ( \"Homepage\" ) async def about ( request ): return PlainTextResponse ( \"About\" ) routes = [ Route ( \"/\" , endpoint = homepage ), Route ( \"/about\" , endpoint = about ), ] app = Starlette ( routes = routes ) The endpoint argument can be one of: A regular function or async function, which accepts a single request argument and which should return a response. A class that implements the ASGI interface, such as Starlette's HTTPEndpoint .","title":"HTTP Routing"},{"location":"routing/#path-parameters","text":"Paths can use URI templating style to capture path components. Route ( '/users/ {username} ' , user ) By default this will capture characters up to the end of the path or the next / . You can use convertors to modify what is captured. The available convertors are: str returns a string, and is the default. int returns a Python integer. float returns a Python float. uuid return a Python uuid.UUID instance. path returns the rest of the path, including any additional / characters. Convertors are used by prefixing them with a colon, like so: Route ( '/users/{user_id:int}' , user ) Route ( '/floating-point/{number:float}' , floating_point ) Route ( '/uploaded/{rest_of_path:path}' , uploaded ) If you need a different converter that is not defined, you can create your own. See below an example on how to create a datetime convertor, and how to register it: from datetime import datetime from starlette.convertors import Convertor , register_url_convertor class DateTimeConvertor ( Convertor ): regex = \"[0-9] {4} -[0-9] {2} -[0-9] {2} T[0-9] {2} :[0-9] {2} :[0-9] {2} (.[0-9]+)?\" def convert ( self , value : str ) -> datetime : return datetime . strptime ( value , \"%Y-%m- %d T%H:%M:%S\" ) def to_string ( self , value : datetime ) -> str : return value . strftime ( \"%Y-%m- %d T%H:%M:%S\" ) register_url_convertor ( \"datetime\" , DateTimeConvertor ()) After registering it, you'll be able to use it as: Route ( '/history/{date:datetime}' , history ) Path parameters are made available in the request, as the request.path_params dictionary. async def user ( request ): user_id = request . path_params [ 'user_id' ] ...","title":"Path Parameters"},{"location":"routing/#handling-http-methods","text":"Routes can also specify which HTTP methods are handled by an endpoint: Route ( '/users/{user_id:int}' , user , methods = [ \"GET\" , \"POST\" ]) By default function endpoints will only accept GET requests, unless specified.","title":"Handling HTTP methods"},{"location":"routing/#submounting-routes","text":"In large applications you might find that you want to break out parts of the routing table, based on a common path prefix. routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = [ Route ( '/' , users , methods = [ 'GET' , 'POST' ]), Route ( '/ {username} ' , user ), ]) ] This style allows you to define different subsets of the routing table in different parts of your project. from myproject import users , auth routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = users . routes ), Mount ( '/auth' , routes = auth . routes ), ] You can also use mounting to include sub-applications within your Starlette application. For example... # This is a standalone static files server: app = StaticFiles ( directory = \"static\" ) # This is a static files server mounted within a Starlette application, # underneath the \"/static\" path. routes = [ ... Mount ( \"/static\" , app = StaticFiles ( directory = \"static\" ), name = \"static\" ) ] app = Starlette ( routes = routes )","title":"Submounting routes"},{"location":"routing/#reverse-url-lookups","text":"You'll often want to be able to generate the URL for a particular route, such as in cases where you need to return a redirect response. routes = [ Route ( \"/\" , homepage , name = \"homepage\" ) ] # We can use the following to return a URL... url = request . url_for ( \"homepage\" ) URL lookups can include path parameters... routes = [ Route ( \"/users/ {username} \" , user , name = \"user_detail\" ) ] # We can use the following to return a URL... url = request . url_for ( \"user_detail\" , username =... ) If a Mount includes a name , then submounts should use a {prefix}:{name} style for reverse URL lookups. routes = [ Mount ( \"/users\" , name = \"users\" , routes = [ Route ( \"/\" , user , name = \"user_list\" ), Route ( \"/ {username} \" , user , name = \"user_detail\" ) ]) ] # We can use the following to return URLs... url = request . url_for ( \"users:user_list\" ) url = request . url_for ( \"users:user_detail\" , username =... ) Mounted applications may include a path=... parameter. routes = [ ... Mount ( \"/static\" , app = StaticFiles ( directory = \"static\" ), name = \"static\" ) ] # We can use the following to return URLs... url = request . url_for ( \"static\" , path = \"/css/base.css\" ) For cases where there is no request instance, you can make reverse lookups against the application, although these will only return the URL path. url = app . url_path_for ( \"user_detail\" , username =... )","title":"Reverse URL lookups"},{"location":"routing/#host-based-routing","text":"If you want to use different routes for the same path based on the Host header. Note that port is removed from the Host header when matching. For example, Host (host='example.org:3600', ...) will be processed even if the Host header contains or does not contain a port other than 3600 ( example.org:5600 , example.org ). Therefore, you can specify the port if you need it for use in url_for . There are several ways to connect host-based routes to your application site = Router () # Use eg. `@site.route()` to configure this. api = Router () # Use eg. `@api.route()` to configure this. news = Router () # Use eg. `@news.route()` to configure this. routes = [ Host ( 'api.example.org' , api , name = \"site_api\" ) ] app = Starlette ( routes = routes ) app . host ( 'www.example.org' , site , name = \"main_site\" ) news_host = Host ( 'news.example.org' , news ) app . router . routes . append ( news_host ) URL lookups can include host parameters just like path parameters routes = [ Host ( \" {subdomain} .example.org\" , name = \"sub\" , app = Router ( routes = [ Mount ( \"/users\" , name = \"users\" , routes = [ Route ( \"/\" , user , name = \"user_list\" ), Route ( \"/ {username} \" , user , name = \"user_detail\" ) ]) ])) ] ... url = request . url_for ( \"sub:users:user_detail\" , username =... , subdomain =... ) url = request . url_for ( \"sub:users:user_list\" , subdomain =... )","title":"Host-based routing"},{"location":"routing/#route-priority","text":"Incoming paths are matched against each Route in order. In cases where more that one route could match an incoming path, you should take care to ensure that more specific routes are listed before general cases. For example: # Don't do this: `/users/me` will never match incoming requests. routes = [ Route ( '/users/ {username} ' , user ), Route ( '/users/me' , current_user ), ] # Do this: `/users/me` is tested first. routes = [ Route ( '/users/me' , current_user ), Route ( '/users/ {username} ' , user ), ]","title":"Route priority"},{"location":"routing/#working-with-router-instances","text":"If you're working at a low-level you might want to use a plain Router instance, rather that creating a Starlette application. This gives you a lightweight ASGI application that just provides the application routing, without wrapping it up in any middleware. app = Router ( routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = [ Route ( '/' , users , methods = [ 'GET' , 'POST' ]), Route ( '/ {username} ' , user ), ]) ])","title":"Working with Router instances"},{"location":"routing/#websocket-routing","text":"When working with WebSocket endpoints, you should use WebSocketRoute instead of the usual Route . Path parameters, and reverse URL lookups for WebSocketRoute work the the same as HTTP Route , which can be found in the HTTP Route section above. from starlette.applications import Starlette from starlette.routing import WebSocketRoute async def websocket_index ( websocket ): await websocket . accept () await websocket . send_text ( \"Hello, websocket!\" ) await websocket . close () async def websocket_user ( websocket ): name = websocket . path_params [ \"name\" ] await websocket . accept () await websocket . send_text ( f \"Hello, { name } \" ) await websocket . close () routes = [ WebSocketRoute ( \"/\" , endpoint = websocket_index ), WebSocketRoute ( \"/ {name} \" , endpoint = websocket_user ), ] app = Starlette ( routes = routes ) The endpoint argument can be one of: An async function, which accepts a single websocket argument. A class that implements the ASGI interface, such as Starlette's WebSocketEndpoint .","title":"WebSocket Routing"},{"location":"schemas/","text":"Starlette supports generating API schemas, such as the widely used OpenAPI specification . (Formerly known as \"Swagger\".) Schema generation works by inspecting the routes on the application through app.routes , and using the docstrings or other attributes on the endpoints in order to determine a complete API schema. Starlette is not tied to any particular schema generation or validation tooling, but includes a simple implementation that generates OpenAPI schemas based on the docstrings. from starlette.applications import Starlette from starlette.routing import Route from starlette.schemas import SchemaGenerator schemas = SchemaGenerator ( { \"openapi\" : \"3.0.0\" , \"info\" : { \"title\" : \"Example API\" , \"version\" : \"1.0\" }} ) def list_users ( request ): \"\"\" responses: 200: description: A list of users. examples: [{\"username\": \"tom\"}, {\"username\": \"lucy\"}] \"\"\" raise NotImplementedError () def create_user ( request ): \"\"\" responses: 200: description: A user. examples: {\"username\": \"tom\"} \"\"\" raise NotImplementedError () def openapi_schema ( request ): return schemas . OpenAPIResponse ( request = request ) routes = [ Route ( \"/users\" , endpoint = list_users , methods = [ \"GET\" ]), Route ( \"/users\" , endpoint = create_user , methods = [ \"POST\" ]), Route ( \"/schema\" , endpoint = openapi_schema , include_in_schema = False ) ] app = Starlette ( routes = routes ) We can now access an OpenAPI schema at the \"/schema\" endpoint. You can generate the API Schema directly with .get_schema(routes) : schema = schemas . get_schema ( routes = app . routes ) assert schema == { \"openapi\" : \"3.0.0\" , \"info\" : { \"title\" : \"Example API\" , \"version\" : \"1.0\" }, \"paths\" : { \"/users\" : { \"get\" : { \"responses\" : { 200 : { \"description\" : \"A list of users.\" , \"examples\" : [{ \"username\" : \"tom\" }, { \"username\" : \"lucy\" }], } } }, \"post\" : { \"responses\" : { 200 : { \"description\" : \"A user.\" , \"examples\" : { \"username\" : \"tom\" }} } }, }, }, } You might also want to be able to print out the API schema, so that you can use tooling such as generating API documentation. if __name__ == '__main__' : assert sys . argv [ - 1 ] in ( \"run\" , \"schema\" ), \"Usage: example.py [run|schema]\" if sys . argv [ - 1 ] == \"run\" : uvicorn . run ( \"example:app\" , host = '0.0.0.0' , port = 8000 ) elif sys . argv [ - 1 ] == \"schema\" : schema = schemas . get_schema ( routes = app . routes ) print ( yaml . dump ( schema , default_flow_style = False )) Third party packages starlette-apispec Easy APISpec integration for Starlette, which supports some object serialization libraries.","title":"API Schemas"},{"location":"schemas/#third-party-packages","text":"","title":"Third party packages"},{"location":"schemas/#starlette-apispec","text":"Easy APISpec integration for Starlette, which supports some object serialization libraries.","title":"starlette-apispec"},{"location":"server-push/","text":"Starlette includes support for HTTP/2 and HTTP/3 server push, making it possible to push resources to the client to speed up page load times. Request.send_push_promise Used to initiate a server push for a resource. If server push is not available this method does nothing. Signature: send_push_promise(path) path - A string denoting the path of the resource. from starlette.applications import Starlette from starlette.responses import HTMLResponse from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles async def homepage ( request ): \"\"\" Homepage which uses server push to deliver the stylesheet. \"\"\" await request . send_push_promise ( \"/static/style.css\" ) return HTMLResponse ( '<html><head><link rel=\"stylesheet\" href=\"/static/style.css\"/></head></html>' ) routes = [ Route ( \"/\" , endpoint = homepage ), Mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) ] app = Starlette ( routes = routes )","title":"Server Push"},{"location":"server-push/#requestsend_push_promise","text":"Used to initiate a server push for a resource. If server push is not available this method does nothing. Signature: send_push_promise(path) path - A string denoting the path of the resource. from starlette.applications import Starlette from starlette.responses import HTMLResponse from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles async def homepage ( request ): \"\"\" Homepage which uses server push to deliver the stylesheet. \"\"\" await request . send_push_promise ( \"/static/style.css\" ) return HTMLResponse ( '<html><head><link rel=\"stylesheet\" href=\"/static/style.css\"/></head></html>' ) routes = [ Route ( \"/\" , endpoint = homepage ), Mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) ] app = Starlette ( routes = routes )","title":"Request.send_push_promise"},{"location":"staticfiles/","text":"Starlette also includes a StaticFiles class for serving files in a given directory: StaticFiles Signature: StaticFiles(directory=None, packages=None, check_dir=True) directory - A string or os.Pathlike denoting a directory path. packages - A list of strings or list of tuples of strings of python packages. html - Run in HTML mode. Automatically loads index.html for directories if such file exist. check_dir - Ensure that the directory exists upon instantiation. Defaults to True . You can combine this ASGI application with Starlette's routing to provide comprehensive static file serving. from starlette.applications import Starlette from starlette.routing import Mount from starlette.staticfiles import StaticFiles routes = [ ... Mount ( '/static' , app = StaticFiles ( directory = 'static' ), name = \"static\" ), ] app = Starlette ( routes = routes ) Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. In HTML mode if 404.html file exists it will be shown as 404 response. The packages option can be used to include \"static\" directories contained within a python package. The Python \"bootstrap4\" package is an example of this. from starlette.applications import Starlette from starlette.routing import Mount from starlette.staticfiles import StaticFiles routes = [ ... Mount ( '/static' , app = StaticFiles ( directory = 'static' , packages = [ 'bootstrap4' ]), name = \"static\" ), ] app = Starlette ( routes = routes ) By default StaticFiles will look for statics directory in each package, you can change the default directory by specifying a tuple of strings. routes = [ ... Mount ( '/static' , app = StaticFiles ( packages = [( 'bootstrap4' , 'static' )]), name = \"static\" ), ] You may prefer to include static files directly inside the \"static\" directory rather than using Python packaging to include static files, but it can be useful for bundling up reusable components.","title":"Static Files"},{"location":"staticfiles/#staticfiles","text":"Signature: StaticFiles(directory=None, packages=None, check_dir=True) directory - A string or os.Pathlike denoting a directory path. packages - A list of strings or list of tuples of strings of python packages. html - Run in HTML mode. Automatically loads index.html for directories if such file exist. check_dir - Ensure that the directory exists upon instantiation. Defaults to True . You can combine this ASGI application with Starlette's routing to provide comprehensive static file serving. from starlette.applications import Starlette from starlette.routing import Mount from starlette.staticfiles import StaticFiles routes = [ ... Mount ( '/static' , app = StaticFiles ( directory = 'static' ), name = \"static\" ), ] app = Starlette ( routes = routes ) Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. In HTML mode if 404.html file exists it will be shown as 404 response. The packages option can be used to include \"static\" directories contained within a python package. The Python \"bootstrap4\" package is an example of this. from starlette.applications import Starlette from starlette.routing import Mount from starlette.staticfiles import StaticFiles routes = [ ... Mount ( '/static' , app = StaticFiles ( directory = 'static' , packages = [ 'bootstrap4' ]), name = \"static\" ), ] app = Starlette ( routes = routes ) By default StaticFiles will look for statics directory in each package, you can change the default directory by specifying a tuple of strings. routes = [ ... Mount ( '/static' , app = StaticFiles ( packages = [( 'bootstrap4' , 'static' )]), name = \"static\" ), ] You may prefer to include static files directly inside the \"static\" directory rather than using Python packaging to include static files, but it can be useful for bundling up reusable components.","title":"StaticFiles"},{"location":"templates/","text":"Starlette is not strictly coupled to any particular templating engine, but Jinja2 provides an excellent choice. Starlette provides a simple way to get jinja2 configured. This is probably what you want to use by default. from starlette.applications import Starlette from starlette.routing import Route , Mount from starlette.templating import Jinja2Templates from starlette.staticfiles import StaticFiles templates = Jinja2Templates ( directory = 'templates' ) async def homepage ( request ): return templates . TemplateResponse ( 'index.html' , { 'request' : request }) routes = [ Route ( '/' , endpoint = homepage ), Mount ( '/static' , StaticFiles ( directory = 'static' ), name = 'static' ) ] app = Starlette ( debug = True , routes = routes ) Note that the incoming request instance must be included as part of the template context. The Jinja2 template context will automatically include a url_for function, so we can correctly hyperlink to other pages within the application. For example, we can link to static files from within our HTML templates: < link href = \"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel = \"stylesheet\" > If you want to use custom filters , you will need to update the env property of Jinja2Templates : from commonmark import commonmark from starlette.templating import Jinja2Templates def marked_filter ( text ): return commonmark ( text ) templates = Jinja2Templates ( directory = 'templates' ) templates . env . filters [ 'marked' ] = marked_filter Testing template responses When using the test client, template responses include .template and .context attributes. def test_homepage (): client = TestClient ( app ) response = client . get ( \"/\" ) assert response . status_code == 200 assert response . template . name == 'index.html' assert \"request\" in response . context Customizing Jinja2 Environment Jinja2Templates accepts all options supported by Jinja2 Environment . This will allow more control over the Environment instance created by Starlette. For the list of options available to Environment you can check Jinja2 documentation here from starlette.templating import Jinja2Templates templates = Jinja2Templates ( directory = 'templates' , autoescape = False , auto_reload = True ) Asynchronous template rendering Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead we'd recommend that you ensure that your endpoints perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.","title":"Templates"},{"location":"templates/#testing-template-responses","text":"When using the test client, template responses include .template and .context attributes. def test_homepage (): client = TestClient ( app ) response = client . get ( \"/\" ) assert response . status_code == 200 assert response . template . name == 'index.html' assert \"request\" in response . context","title":"Testing template responses"},{"location":"templates/#customizing-jinja2-environment","text":"Jinja2Templates accepts all options supported by Jinja2 Environment . This will allow more control over the Environment instance created by Starlette. For the list of options available to Environment you can check Jinja2 documentation here from starlette.templating import Jinja2Templates templates = Jinja2Templates ( directory = 'templates' , autoescape = False , auto_reload = True )","title":"Customizing Jinja2 Environment"},{"location":"templates/#asynchronous-template-rendering","text":"Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead we'd recommend that you ensure that your endpoints perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.","title":"Asynchronous template rendering"},{"location":"testclient/","text":"The test client allows you to make requests against your ASGI application, using the httpx library. from starlette.responses import HTMLResponse from starlette.testclient import TestClient async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = HTMLResponse ( '<html><body>Hello, world!</body></html>' ) await response ( scope , receive , send ) def test_app (): client = TestClient ( app ) response = client . get ( '/' ) assert response . status_code == 200 The test client exposes the same interface as any other httpx session. In particular, note that the calls to make a request are just standard function calls, not awaitables. You can use any of httpx standard API, such as authentication, session cookies handling, or file uploads. For example, to set headers on the TestClient you can do: client = TestClient ( app ) # Set headers on the client for future requests client . headers = { \"Authorization\" : \"...\" } response = client . get ( \"/\" ) # Set headers for each request separately response = client . get ( \"/\" , headers = { \"Authorization\" : \"...\" }) And for example to send files with the TestClient: client = TestClient ( app ) # Send a single file with open ( \"example.txt\" , \"rb\" ) as f : response = client . post ( \"/form\" , files = { \"file\" : f }) # Send multiple files with open ( \"example.txt\" , \"rb\" ) as f1 : with open ( \"example.png\" , \"rb\" ) as f2 : files = { \"file1\" : f1 , \"file2\" : ( \"filename\" , f2 , \"image/png\" )} response = client . post ( \"/form\" , files = files ) For more information you can check the httpx documentation . By default the TestClient will raise any exceptions that occur in the application. Occasionally you might want to test the content of 500 error responses, rather than allowing client to raise the server exception. In this case you should use client = TestClient(app, raise_server_exceptions=False) . Note If you want the TestClient to run lifespan events ( on_startup , on_shutdown , or lifespan ), you will need to use the TestClient as a context manager. Otherwise, the events will not be triggered when the TestClient is instantiated. You can learn more about it here . Selecting the Async backend TestClient takes arguments backend (a string) and backend_options (a dictionary). These options are passed to anyio.start_blocking_portal() . See the anyio documentation for more information about the accepted backend options. By default, asyncio is used with default options. To run Trio , pass backend=\"trio\" . For example: def test_app () with TestClient ( app , backend = \"trio\" ) as client : ... To run asyncio with uvloop , pass backend_options={\"use_uvloop\": True} . For example: def test_app () with TestClient ( app , backend_options = { \"use_uvloop\" : True }) as client : ... Testing WebSocket sessions You can also test websocket sessions with the test client. The httpx library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocket async def app ( scope , receive , send ): assert scope [ 'type' ] == 'websocket' websocket = WebSocket ( scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () def test_app (): client = TestClient ( app ) with client . websocket_connect ( '/' ) as websocket : data = websocket . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client. Establishing a test session .websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as httpx.get() . May raise starlette.websockets.WebSocketDisconnect if the application does not accept the websocket connection. websocket_connect() must be used as a context manager (in a with block). Note The params argument is not supported by websocket_connect . If you need to pass query arguments, hard code it directly in the URL. with client . websocket_connect ( '/path?foo=bar' ) as websocket : ... Sending data .send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data, mode=\"text\") - Send the given data to the application. Use mode=\"binary\" to send JSON over binary data frames. Receiving data .receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json(mode=\"text\") - Wait for incoming json data sent by the application and return it. Use mode=\"binary\" to receive JSON over binary data frames. May raise starlette.websockets.WebSocketDisconnect . Closing the connection .close(code=1000) - Perform a client-side close of the websocket connection. Asynchronous tests Sometimes you will want to do async things outside of your application. For example, you might want to check the state of your database after calling your app using your existing async database client / infrastructure. For these situations, using TestClient is difficult because it creates it's own event loop and async resources (like a database connection) often cannot be shared across event loops. The simplest way to work around this is to just make your entire test async and use an async client, like httpx.AsyncClient . Here is an example of such a test: from httpx import AsyncClient from starlette.applications import Starlette from starlette.routing import Route from starlette.requests import Request from starlette.responses import PlainTextResponse def hello ( request : Request ) -> PlainTextResponse : return PlainTextResponse ( \"Hello World!\" ) app = Starlette ( routes = [ Route ( \"/\" , hello )]) # if you're using pytest, you'll need to to add an async marker like: # @pytest.mark.anyio # using https://github.com/agronholm/anyio # or install and configure pytest-asyncio (https://github.com/pytest-dev/pytest-asyncio) async def test_app () -> None : # note: you _must_ set `base_url` for relative urls like \"/\" to work async with AsyncClient ( app = app , base_url = \"http://testserver\" ) as client : r = await client . get ( \"/\" ) assert r . status_code == 200 assert r . text == \"Hello World!\"","title":"Test Client"},{"location":"testclient/#selecting-the-async-backend","text":"TestClient takes arguments backend (a string) and backend_options (a dictionary). These options are passed to anyio.start_blocking_portal() . See the anyio documentation for more information about the accepted backend options. By default, asyncio is used with default options. To run Trio , pass backend=\"trio\" . For example: def test_app () with TestClient ( app , backend = \"trio\" ) as client : ... To run asyncio with uvloop , pass backend_options={\"use_uvloop\": True} . For example: def test_app () with TestClient ( app , backend_options = { \"use_uvloop\" : True }) as client : ...","title":"Selecting the Async backend"},{"location":"testclient/#testing-websocket-sessions","text":"You can also test websocket sessions with the test client. The httpx library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocket async def app ( scope , receive , send ): assert scope [ 'type' ] == 'websocket' websocket = WebSocket ( scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () def test_app (): client = TestClient ( app ) with client . websocket_connect ( '/' ) as websocket : data = websocket . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client.","title":"Testing WebSocket sessions"},{"location":"testclient/#establishing-a-test-session","text":".websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as httpx.get() . May raise starlette.websockets.WebSocketDisconnect if the application does not accept the websocket connection. websocket_connect() must be used as a context manager (in a with block). Note The params argument is not supported by websocket_connect . If you need to pass query arguments, hard code it directly in the URL. with client . websocket_connect ( '/path?foo=bar' ) as websocket : ...","title":"Establishing a test session"},{"location":"testclient/#sending-data","text":".send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data, mode=\"text\") - Send the given data to the application. Use mode=\"binary\" to send JSON over binary data frames.","title":"Sending data"},{"location":"testclient/#receiving-data","text":".receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json(mode=\"text\") - Wait for incoming json data sent by the application and return it. Use mode=\"binary\" to receive JSON over binary data frames. May raise starlette.websockets.WebSocketDisconnect .","title":"Receiving data"},{"location":"testclient/#closing-the-connection","text":".close(code=1000) - Perform a client-side close of the websocket connection.","title":"Closing the connection"},{"location":"testclient/#asynchronous-tests","text":"Sometimes you will want to do async things outside of your application. For example, you might want to check the state of your database after calling your app using your existing async database client / infrastructure. For these situations, using TestClient is difficult because it creates it's own event loop and async resources (like a database connection) often cannot be shared across event loops. The simplest way to work around this is to just make your entire test async and use an async client, like httpx.AsyncClient . Here is an example of such a test: from httpx import AsyncClient from starlette.applications import Starlette from starlette.routing import Route from starlette.requests import Request from starlette.responses import PlainTextResponse def hello ( request : Request ) -> PlainTextResponse : return PlainTextResponse ( \"Hello World!\" ) app = Starlette ( routes = [ Route ( \"/\" , hello )]) # if you're using pytest, you'll need to to add an async marker like: # @pytest.mark.anyio # using https://github.com/agronholm/anyio # or install and configure pytest-asyncio (https://github.com/pytest-dev/pytest-asyncio) async def test_app () -> None : # note: you _must_ set `base_url` for relative urls like \"/\" to work async with AsyncClient ( app = app , base_url = \"http://testserver\" ) as client : r = await client . get ( \"/\" ) assert r . status_code == 200 assert r . text == \"Hello World!\"","title":"Asynchronous tests"},{"location":"third-party-packages/","text":"Starlette has a rapidly growing community of developers, building tools that integrate into Starlette, tools that depend on Starlette, etc. Here are some of those third party packages: Backports Python 3.5 port GitHub Plugins Authlib GitHub | Documentation The ultimate Python library in building OAuth and OpenID Connect clients and servers. Check out how to integrate with Starlette . ChannelBox GitHub Another solution for websocket broadcast. Send messages to channel groups from any part of your code. Checkout MySimpleChat , a simple chat application built using channel-box and starlette . Imia GitHub An authentication framework for Starlette with pluggable authenticators and login/logout flow. Mangum GitHub Serverless ASGI adapter for AWS Lambda & API Gateway. Nejma GitHub Manage and send messages to groups of channels using websockets. Checkout nejma-chat , a simple chat application built using nejma and starlette . Scout APM GitHub An APM (Application Performance Monitoring) solution that can instrument your application to find performance bottlenecks. SpecTree GitHub Generate OpenAPI spec document and validate request & response with Python annotations. Less boilerplate code(no need for YAML). Starlette APISpec GitHub Simple APISpec integration for Starlette. Document your REST API built with Starlette by declaring OpenAPI (Swagger) schemas in YAML format in your endpoint's docstrings. Starlette Context GitHub Middleware for Starlette that allows you to store and access the context data of a request. Can be used with logging so logs automatically use request headers such as x-request-id or x-correlation-id. Starlette Cramjam GitHub A Starlette middleware that allows brotli , gzip and deflate compression algorithm with a minimal requirements. Starlette OAuth2 API GitLab A starlette middleware to add authentication and authorization through JWTs. It relies solely on an auth provider to issue access and/or id tokens to clients. Starlette Prometheus GitHub A plugin for providing an endpoint that exposes Prometheus metrics based on its official python client . Starlette WTF GitHub A simple tool for integrating Starlette and WTForms. It is modeled on the excellent Flask-WTF library. Starlette-Login GitHub | Documentation User session management for Starlette. It handles the common tasks of logging in, logging out, and remembering your users' sessions over extended periods of time. Starsessions GitHub An alternate session support implementation with customizable storage backends. webargs-starlette GitHub Declarative request parsing and validation for Starlette, built on top of webargs . Allows you to parse querystring, JSON, form, headers, and cookies using type annotations. DecoRouter GitHub FastAPI style routing for Starlette. Allows you to use decorators to generate routing tables. Starception GitHub Beautiful exception page for Starlette apps. Starlette-Admin GitHub | Documentation Simple and extensible admin interface framework. Built with Tabler and Datatables , it allows you to quickly generate fully customizable admin interface for your models. You can export your data to many formats ( CSV , PDF , Excel , etc), filter your data with complex query including AND and OR conditions, upload files, ... Frameworks FastAPI GitHub | Documentation High performance, easy to learn, fast to code, ready for production web API framework. Inspired by APIStar 's previous server system with type declarations for route parameters, based on the OpenAPI specification version 3.0.0+ (with JSON Schema), powered by Pydantic for the data handling. Flama GitHub | Documentation Formerly Starlette API. Flama aims to bring a layer on top of Starlette to provide an easy to learn and fast to develop approach for building highly performant GraphQL and REST APIs. In the same way of Starlette is, Flama is a perfect option for developing asynchronous and production-ready services. Greppo GitHub | Documentation A Python framework for building geospatial dashboards and web-applications. Greppo is an open-source Python framework that makes it easy to build geospatial dashboards and web-applications. It provides a toolkit to quickly integrate data, algorithms, visualizations and UI for interactivity. It provides APIs to the update the variables in the backend, recompute the logic, and reflect the changes in the frontend (data mutation hook). Responder GitHub | Documentation Async web service framework. Some Features: flask-style route expression, yaml support, OpenAPI schema generation, background tasks, graphql. Starlette-apps Roll your own framework with a simple app system, like Django-GDAPS or CakePHP . GitHub Dark Star A simple framework to help minimise the code needed to get HTML to the browser. Changes your file paths into Starlette routes and puts your view code right next to your template. Includes support for htmx to help enhance your frontend. Docs GitHub Xpresso A flexible and extendable web framework built on top of Starlette, Pydantic and di . GitHub | Documentation Apiman An extension to integrate Swagger/OpenAPI document easily for Starlette project and provide SwaggerUI and RedocUI . GitHub Starlette-Babel Provides translations, localization, and timezone support via Babel integration. GitHub","title":"Third Party Packages"},{"location":"third-party-packages/#backports","text":"","title":"Backports"},{"location":"third-party-packages/#python-35-port","text":"GitHub","title":"Python 3.5 port"},{"location":"third-party-packages/#plugins","text":"","title":"Plugins"},{"location":"third-party-packages/#authlib","text":"GitHub | Documentation The ultimate Python library in building OAuth and OpenID Connect clients and servers. Check out how to integrate with Starlette .","title":"Authlib"},{"location":"third-party-packages/#channelbox","text":"GitHub Another solution for websocket broadcast. Send messages to channel groups from any part of your code. Checkout MySimpleChat , a simple chat application built using channel-box and starlette .","title":"ChannelBox"},{"location":"third-party-packages/#imia","text":"GitHub An authentication framework for Starlette with pluggable authenticators and login/logout flow.","title":"Imia"},{"location":"third-party-packages/#mangum","text":"GitHub Serverless ASGI adapter for AWS Lambda & API Gateway.","title":"Mangum"},{"location":"third-party-packages/#nejma","text":"GitHub Manage and send messages to groups of channels using websockets. Checkout nejma-chat , a simple chat application built using nejma and starlette .","title":"Nejma"},{"location":"third-party-packages/#scout-apm","text":"GitHub An APM (Application Performance Monitoring) solution that can instrument your application to find performance bottlenecks.","title":"Scout APM"},{"location":"third-party-packages/#spectree","text":"GitHub Generate OpenAPI spec document and validate request & response with Python annotations. Less boilerplate code(no need for YAML).","title":"SpecTree"},{"location":"third-party-packages/#starlette-apispec","text":"GitHub Simple APISpec integration for Starlette. Document your REST API built with Starlette by declaring OpenAPI (Swagger) schemas in YAML format in your endpoint's docstrings.","title":"Starlette APISpec"},{"location":"third-party-packages/#starlette-context","text":"GitHub Middleware for Starlette that allows you to store and access the context data of a request. Can be used with logging so logs automatically use request headers such as x-request-id or x-correlation-id.","title":"Starlette Context"},{"location":"third-party-packages/#starlette-cramjam","text":"GitHub A Starlette middleware that allows brotli , gzip and deflate compression algorithm with a minimal requirements.","title":"Starlette Cramjam"},{"location":"third-party-packages/#starlette-oauth2-api","text":"GitLab A starlette middleware to add authentication and authorization through JWTs. It relies solely on an auth provider to issue access and/or id tokens to clients.","title":"Starlette OAuth2 API"},{"location":"third-party-packages/#starlette-prometheus","text":"GitHub A plugin for providing an endpoint that exposes Prometheus metrics based on its official python client .","title":"Starlette Prometheus"},{"location":"third-party-packages/#starlette-wtf","text":"GitHub A simple tool for integrating Starlette and WTForms. It is modeled on the excellent Flask-WTF library.","title":"Starlette WTF"},{"location":"third-party-packages/#starlette-login","text":"GitHub | Documentation User session management for Starlette. It handles the common tasks of logging in, logging out, and remembering your users' sessions over extended periods of time.","title":"Starlette-Login"},{"location":"third-party-packages/#starsessions","text":"GitHub An alternate session support implementation with customizable storage backends.","title":"Starsessions"},{"location":"third-party-packages/#webargs-starlette","text":"GitHub Declarative request parsing and validation for Starlette, built on top of webargs . Allows you to parse querystring, JSON, form, headers, and cookies using type annotations.","title":"webargs-starlette"},{"location":"third-party-packages/#decorouter","text":"GitHub FastAPI style routing for Starlette. Allows you to use decorators to generate routing tables.","title":"DecoRouter"},{"location":"third-party-packages/#starception","text":"GitHub Beautiful exception page for Starlette apps.","title":"Starception"},{"location":"third-party-packages/#starlette-admin","text":"GitHub | Documentation Simple and extensible admin interface framework. Built with Tabler and Datatables , it allows you to quickly generate fully customizable admin interface for your models. You can export your data to many formats ( CSV , PDF , Excel , etc), filter your data with complex query including AND and OR conditions, upload files, ...","title":"Starlette-Admin"},{"location":"third-party-packages/#frameworks","text":"","title":"Frameworks"},{"location":"third-party-packages/#fastapi","text":"GitHub | Documentation High performance, easy to learn, fast to code, ready for production web API framework. Inspired by APIStar 's previous server system with type declarations for route parameters, based on the OpenAPI specification version 3.0.0+ (with JSON Schema), powered by Pydantic for the data handling.","title":"FastAPI"},{"location":"third-party-packages/#flama","text":"GitHub | Documentation Formerly Starlette API. Flama aims to bring a layer on top of Starlette to provide an easy to learn and fast to develop approach for building highly performant GraphQL and REST APIs. In the same way of Starlette is, Flama is a perfect option for developing asynchronous and production-ready services.","title":"Flama"},{"location":"third-party-packages/#greppo","text":"GitHub | Documentation A Python framework for building geospatial dashboards and web-applications. Greppo is an open-source Python framework that makes it easy to build geospatial dashboards and web-applications. It provides a toolkit to quickly integrate data, algorithms, visualizations and UI for interactivity. It provides APIs to the update the variables in the backend, recompute the logic, and reflect the changes in the frontend (data mutation hook).","title":"Greppo"},{"location":"third-party-packages/#responder","text":"GitHub | Documentation Async web service framework. Some Features: flask-style route expression, yaml support, OpenAPI schema generation, background tasks, graphql.","title":"Responder"},{"location":"third-party-packages/#starlette-apps","text":"Roll your own framework with a simple app system, like Django-GDAPS or CakePHP . GitHub","title":"Starlette-apps"},{"location":"third-party-packages/#dark-star","text":"A simple framework to help minimise the code needed to get HTML to the browser. Changes your file paths into Starlette routes and puts your view code right next to your template. Includes support for htmx to help enhance your frontend. Docs GitHub","title":"Dark Star"},{"location":"third-party-packages/#xpresso","text":"A flexible and extendable web framework built on top of Starlette, Pydantic and di . GitHub | Documentation","title":"Xpresso"},{"location":"third-party-packages/#apiman","text":"An extension to integrate Swagger/OpenAPI document easily for Starlette project and provide SwaggerUI and RedocUI . GitHub","title":"Apiman"},{"location":"third-party-packages/#starlette-babel","text":"Provides translations, localization, and timezone support via Babel integration. GitHub","title":"Starlette-Babel"},{"location":"websockets/","text":"Starlette includes a WebSocket class that fulfils a similar role to the HTTP request, but that allows sending and receiving data on a websocket. WebSocket Signature: WebSocket(scope, receive=None, send=None) from starlette.websockets import WebSocket async def app ( scope , receive , send ): websocket = WebSocket ( scope = scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () WebSockets present a mapping interface, so you can use them in the same way as a scope . For instance: websocket['path'] will return the ASGI path. URL The websocket URL is accessed as websocket.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: websocket.url.path , websocket.url.port , websocket.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: websocket.headers['sec-websocket-version'] Query Parameters Query parameters are exposed as an immutable multi-dict. For example: websocket.query_params['search'] Path Parameters Router path parameters are exposed as a dictionary interface. For example: websocket.path_params['username'] Accepting the connection await websocket.accept(subprotocol=None, headers=None) Sending data await websocket.send_text(data) await websocket.send_bytes(data) await websocket.send_json(data) JSON messages default to being sent over text data frames, from version 0.10.0 onwards. Use websocket.send_json(data, mode=\"binary\") to send JSON over binary data frames. Receiving data await websocket.receive_text() await websocket.receive_bytes() await websocket.receive_json() May raise starlette.websockets.WebSocketDisconnect() . JSON messages default to being received over text data frames, from version 0.10.0 onwards. Use websocket.receive_json(data, mode=\"binary\") to receive JSON over binary data frames. Closing the connection await websocket.close(code=1000, reason=None) Sending and receiving messages If you need to send or receive raw ASGI messages then you should use websocket.send() and websocket.receive() rather than using the raw send and receive callables. This will ensure that the websocket's state is kept correctly updated. await websocket.send(message) await websocket.receive()","title":"WebSockets"},{"location":"websockets/#websocket","text":"Signature: WebSocket(scope, receive=None, send=None) from starlette.websockets import WebSocket async def app ( scope , receive , send ): websocket = WebSocket ( scope = scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () WebSockets present a mapping interface, so you can use them in the same way as a scope . For instance: websocket['path'] will return the ASGI path.","title":"WebSocket"},{"location":"websockets/#url","text":"The websocket URL is accessed as websocket.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: websocket.url.path , websocket.url.port , websocket.url.scheme .","title":"URL"},{"location":"websockets/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: websocket.headers['sec-websocket-version']","title":"Headers"},{"location":"websockets/#query-parameters","text":"Query parameters are exposed as an immutable multi-dict. For example: websocket.query_params['search']","title":"Query Parameters"},{"location":"websockets/#path-parameters","text":"Router path parameters are exposed as a dictionary interface. For example: websocket.path_params['username']","title":"Path Parameters"},{"location":"websockets/#accepting-the-connection","text":"await websocket.accept(subprotocol=None, headers=None)","title":"Accepting the connection"},{"location":"websockets/#sending-data","text":"await websocket.send_text(data) await websocket.send_bytes(data) await websocket.send_json(data) JSON messages default to being sent over text data frames, from version 0.10.0 onwards. Use websocket.send_json(data, mode=\"binary\") to send JSON over binary data frames.","title":"Sending data"},{"location":"websockets/#receiving-data","text":"await websocket.receive_text() await websocket.receive_bytes() await websocket.receive_json() May raise starlette.websockets.WebSocketDisconnect() . JSON messages default to being received over text data frames, from version 0.10.0 onwards. Use websocket.receive_json(data, mode=\"binary\") to receive JSON over binary data frames.","title":"Receiving data"},{"location":"websockets/#closing-the-connection","text":"await websocket.close(code=1000, reason=None)","title":"Closing the connection"},{"location":"websockets/#sending-and-receiving-messages","text":"If you need to send or receive raw ASGI messages then you should use websocket.send() and websocket.receive() rather than using the raw send and receive callables. This will ensure that the websocket's state is kept correctly updated. await websocket.send(message) await websocket.receive()","title":"Sending and receiving messages"}]}